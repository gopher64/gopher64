/* automatically generated by rust-bindgen 0.59.2 */

pub const __BIONIC__: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __NDK_MAJOR__: u32 = 21;
pub const __NDK_MINOR__: u32 = 1;
pub const __NDK_BETA__: u32 = 0;
pub const __NDK_BUILD__: u32 = 6352462;
pub const __NDK_CANARY__: u32 = 0;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const __BITS_PER_LONG: u32 = 32;
pub const __FD_SETSIZE: u32 = 1024;
pub const AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT: u32 = 8;
pub const __PRI_64_prefix: &[u8; 3usize] = b"ll\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const GAME_ACTIVITY_POINTER_INFO_AXIS_COUNT: u32 = 48;
pub const GAMEACTIVITY_MAX_NUM_POINTERS_IN_MOTION_EVENT: u32 = 8;
pub const GAMEACTIVITY_MAX_NUM_HISTORICAL_IN_MOTION_EVENT: u32 = 8;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLRDNORM: u32 = 64;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRNORM: u32 = 256;
pub const POLLWRBAND: u32 = 512;
pub const POLLMSG: u32 = 1024;
pub const POLLREMOVE: u32 = 4096;
pub const POLLRDHUP: u32 = 8192;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const X86_FXSR_MAGIC: u32 = 0;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 255;
pub const TMP_MAX: u32 = 308915776;
pub const CHAR_BIT: u32 = 8;
pub const LONG_BIT: u32 = 32;
pub const WORD_BIT: u32 = 32;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: u32 = 4294967295;
pub const LONG_MAX: u32 = 2147483647;
pub const LONG_MIN: i32 = -2147483648;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_LONG_MAX: i32 = -1;
pub const UID_MAX: u32 = 4294967295;
pub const GID_MAX: u32 = 4294967295;
pub const SIZE_T_MAX: u32 = 4294967295;
pub const SSIZE_MAX: u32 = 2147483647;
pub const MB_LEN_MAX: u32 = 4;
pub const NZERO: u32 = 20;
pub const IOV_MAX: u32 = 1024;
pub const SEM_VALUE_MAX: u32 = 1073741823;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const __BIONIC_POSIX_FEATURE_MISSING: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: i32 = -1;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: i32 = -1;
pub const _POSIX2_LOCALEDEF: i32 = -1;
pub const _POSIX2_SW_DEV: i32 = -1;
pub const _POSIX2_UPE: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _XOPEN_CRYPT: i32 = -1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const HOST_NAME_MAX: u32 = 255;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const TTY_NAME_MAX: u32 = 32;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const _KERNEL_NSIG: u32 = 32;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const __SIGRTMIN: u32 = 32;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_RESTORER: u32 = 67108864;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const NSIGSEGV: u32 = 7;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const NSIGTRAP: u32 = 5;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const NSIGSYS: u32 = 1;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const _KERNEL__NSIG: u32 = 64;
pub const _NSIG: u32 = 65;
pub const NSIG: u32 = 65;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_MASK: i32 = -4096;
pub const UPAGES: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const SCHED_FLAG_RESET_ON_FORK: u32 = 1;
pub const SCHED_FLAG_RECLAIM: u32 = 2;
pub const SCHED_FLAG_DL_OVERRUN: u32 = 4;
pub const SCHED_FLAG_KEEP_POLICY: u32 = 8;
pub const SCHED_FLAG_KEEP_PARAMS: u32 = 16;
pub const SCHED_FLAG_UTIL_CLAMP_MIN: u32 = 32;
pub const SCHED_FLAG_UTIL_CLAMP_MAX: u32 = 64;
pub const SCHED_FLAG_KEEP_ALL: u32 = 24;
pub const SCHED_FLAG_UTIL_CLAMP: u32 = 96;
pub const SCHED_FLAG_ALL: u32 = 127;
pub const SCHED_OTHER: u32 = 0;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const PTHREAD_CREATE_DETACHED: u32 = 1;
pub const PTHREAD_CREATE_JOINABLE: u32 = 0;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 0;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 0;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 0;
pub const PTHREAD_SCOPE_PROCESS: u32 = 1;
pub const NATIVE_APP_GLUE_MAX_NUM_MOTION_EVENTS: u32 = 16;
pub const NATIVE_APP_GLUE_MAX_HISTORICAL_POINTER_SAMPLES: u32 = 64;
pub const NATIVE_APP_GLUE_MAX_NUM_KEY_EVENTS: u32 = 4;
pub const NATIVE_APP_GLUE_MAX_INPUT_BUFFERS: u32 = 2;
extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __uintptr_t = ::std::os::raw::c_uint;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i32;
pub type uint_fast16_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type uintmax_t = u64;
pub type intmax_t = i64;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_mode_t = ::std::os::raw::c_ushort;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_ushort;
pub type __kernel_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_size_t = ::std::os::raw::c_uint;
pub type __kernel_ssize_t = ::std::os::raw::c_int;
pub type __kernel_ptrdiff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type __gid_t = __kernel_gid32_t;
pub type gid_t = __gid_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __id_t = u32;
pub type id_t = __id_t;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type blksize_t = ::std::os::raw::c_ulong;
pub type caddr_t = __kernel_caddr_t;
pub type clock_t = __kernel_clock_t;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
pub type daddr_t = __kernel_daddr_t;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __mode_t = __kernel_mode_t;
pub type mode_t = __mode_t;
pub type __key_t = __kernel_key_t;
pub type key_t = __key_t;
pub type __ino_t = __kernel_ino_t;
pub type ino_t = __ino_t;
pub type ino64_t = u64;
pub type __nlink_t = u32;
pub type nlink_t = __nlink_t;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type timer_t = __timer_t;
pub type __suseconds_t = __kernel_suseconds_t;
pub type suseconds_t = __suseconds_t;
pub type __useconds_t = u32;
pub type useconds_t = __useconds_t;
pub type dev_t = u32;
pub type __time_t = __kernel_time_t;
pub type time_t = __time_t;
pub type off_t = __kernel_off_t;
pub type loff_t = __kernel_loff_t;
pub type off64_t = loff_t;
pub type __socklen_t = i32;
pub type socklen_t = __socklen_t;
pub type __va_list = __builtin_va_list;
pub type ssize_t = __kernel_ssize_t;
pub type uint_t = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type u_int32_t = u32;
pub type u_int16_t = u16;
pub type u_int8_t = u8;
pub type u_int64_t = u64;
pub const AASSET_MODE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const AASSET_MODE_RANDOM: ::std::os::raw::c_uint = 1;
pub const AASSET_MODE_STREAMING: ::std::os::raw::c_uint = 2;
pub const AASSET_MODE_BUFFER: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const AKEYCODE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const AKEYCODE_SOFT_LEFT: ::std::os::raw::c_uint = 1;
pub const AKEYCODE_SOFT_RIGHT: ::std::os::raw::c_uint = 2;
pub const AKEYCODE_HOME: ::std::os::raw::c_uint = 3;
pub const AKEYCODE_BACK: ::std::os::raw::c_uint = 4;
pub const AKEYCODE_CALL: ::std::os::raw::c_uint = 5;
pub const AKEYCODE_ENDCALL: ::std::os::raw::c_uint = 6;
pub const AKEYCODE_0: ::std::os::raw::c_uint = 7;
pub const AKEYCODE_1: ::std::os::raw::c_uint = 8;
pub const AKEYCODE_2: ::std::os::raw::c_uint = 9;
pub const AKEYCODE_3: ::std::os::raw::c_uint = 10;
pub const AKEYCODE_4: ::std::os::raw::c_uint = 11;
pub const AKEYCODE_5: ::std::os::raw::c_uint = 12;
pub const AKEYCODE_6: ::std::os::raw::c_uint = 13;
pub const AKEYCODE_7: ::std::os::raw::c_uint = 14;
pub const AKEYCODE_8: ::std::os::raw::c_uint = 15;
pub const AKEYCODE_9: ::std::os::raw::c_uint = 16;
pub const AKEYCODE_STAR: ::std::os::raw::c_uint = 17;
pub const AKEYCODE_POUND: ::std::os::raw::c_uint = 18;
pub const AKEYCODE_DPAD_UP: ::std::os::raw::c_uint = 19;
pub const AKEYCODE_DPAD_DOWN: ::std::os::raw::c_uint = 20;
pub const AKEYCODE_DPAD_LEFT: ::std::os::raw::c_uint = 21;
pub const AKEYCODE_DPAD_RIGHT: ::std::os::raw::c_uint = 22;
pub const AKEYCODE_DPAD_CENTER: ::std::os::raw::c_uint = 23;
pub const AKEYCODE_VOLUME_UP: ::std::os::raw::c_uint = 24;
pub const AKEYCODE_VOLUME_DOWN: ::std::os::raw::c_uint = 25;
pub const AKEYCODE_POWER: ::std::os::raw::c_uint = 26;
pub const AKEYCODE_CAMERA: ::std::os::raw::c_uint = 27;
pub const AKEYCODE_CLEAR: ::std::os::raw::c_uint = 28;
pub const AKEYCODE_A: ::std::os::raw::c_uint = 29;
pub const AKEYCODE_B: ::std::os::raw::c_uint = 30;
pub const AKEYCODE_C: ::std::os::raw::c_uint = 31;
pub const AKEYCODE_D: ::std::os::raw::c_uint = 32;
pub const AKEYCODE_E: ::std::os::raw::c_uint = 33;
pub const AKEYCODE_F: ::std::os::raw::c_uint = 34;
pub const AKEYCODE_G: ::std::os::raw::c_uint = 35;
pub const AKEYCODE_H: ::std::os::raw::c_uint = 36;
pub const AKEYCODE_I: ::std::os::raw::c_uint = 37;
pub const AKEYCODE_J: ::std::os::raw::c_uint = 38;
pub const AKEYCODE_K: ::std::os::raw::c_uint = 39;
pub const AKEYCODE_L: ::std::os::raw::c_uint = 40;
pub const AKEYCODE_M: ::std::os::raw::c_uint = 41;
pub const AKEYCODE_N: ::std::os::raw::c_uint = 42;
pub const AKEYCODE_O: ::std::os::raw::c_uint = 43;
pub const AKEYCODE_P: ::std::os::raw::c_uint = 44;
pub const AKEYCODE_Q: ::std::os::raw::c_uint = 45;
pub const AKEYCODE_R: ::std::os::raw::c_uint = 46;
pub const AKEYCODE_S: ::std::os::raw::c_uint = 47;
pub const AKEYCODE_T: ::std::os::raw::c_uint = 48;
pub const AKEYCODE_U: ::std::os::raw::c_uint = 49;
pub const AKEYCODE_V: ::std::os::raw::c_uint = 50;
pub const AKEYCODE_W: ::std::os::raw::c_uint = 51;
pub const AKEYCODE_X: ::std::os::raw::c_uint = 52;
pub const AKEYCODE_Y: ::std::os::raw::c_uint = 53;
pub const AKEYCODE_Z: ::std::os::raw::c_uint = 54;
pub const AKEYCODE_COMMA: ::std::os::raw::c_uint = 55;
pub const AKEYCODE_PERIOD: ::std::os::raw::c_uint = 56;
pub const AKEYCODE_ALT_LEFT: ::std::os::raw::c_uint = 57;
pub const AKEYCODE_ALT_RIGHT: ::std::os::raw::c_uint = 58;
pub const AKEYCODE_SHIFT_LEFT: ::std::os::raw::c_uint = 59;
pub const AKEYCODE_SHIFT_RIGHT: ::std::os::raw::c_uint = 60;
pub const AKEYCODE_TAB: ::std::os::raw::c_uint = 61;
pub const AKEYCODE_SPACE: ::std::os::raw::c_uint = 62;
pub const AKEYCODE_SYM: ::std::os::raw::c_uint = 63;
pub const AKEYCODE_EXPLORER: ::std::os::raw::c_uint = 64;
pub const AKEYCODE_ENVELOPE: ::std::os::raw::c_uint = 65;
pub const AKEYCODE_ENTER: ::std::os::raw::c_uint = 66;
pub const AKEYCODE_DEL: ::std::os::raw::c_uint = 67;
pub const AKEYCODE_GRAVE: ::std::os::raw::c_uint = 68;
pub const AKEYCODE_MINUS: ::std::os::raw::c_uint = 69;
pub const AKEYCODE_EQUALS: ::std::os::raw::c_uint = 70;
pub const AKEYCODE_LEFT_BRACKET: ::std::os::raw::c_uint = 71;
pub const AKEYCODE_RIGHT_BRACKET: ::std::os::raw::c_uint = 72;
pub const AKEYCODE_BACKSLASH: ::std::os::raw::c_uint = 73;
pub const AKEYCODE_SEMICOLON: ::std::os::raw::c_uint = 74;
pub const AKEYCODE_APOSTROPHE: ::std::os::raw::c_uint = 75;
pub const AKEYCODE_SLASH: ::std::os::raw::c_uint = 76;
pub const AKEYCODE_AT: ::std::os::raw::c_uint = 77;
pub const AKEYCODE_NUM: ::std::os::raw::c_uint = 78;
pub const AKEYCODE_HEADSETHOOK: ::std::os::raw::c_uint = 79;
pub const AKEYCODE_FOCUS: ::std::os::raw::c_uint = 80;
pub const AKEYCODE_PLUS: ::std::os::raw::c_uint = 81;
pub const AKEYCODE_MENU: ::std::os::raw::c_uint = 82;
pub const AKEYCODE_NOTIFICATION: ::std::os::raw::c_uint = 83;
pub const AKEYCODE_SEARCH: ::std::os::raw::c_uint = 84;
pub const AKEYCODE_MEDIA_PLAY_PAUSE: ::std::os::raw::c_uint = 85;
pub const AKEYCODE_MEDIA_STOP: ::std::os::raw::c_uint = 86;
pub const AKEYCODE_MEDIA_NEXT: ::std::os::raw::c_uint = 87;
pub const AKEYCODE_MEDIA_PREVIOUS: ::std::os::raw::c_uint = 88;
pub const AKEYCODE_MEDIA_REWIND: ::std::os::raw::c_uint = 89;
pub const AKEYCODE_MEDIA_FAST_FORWARD: ::std::os::raw::c_uint = 90;
pub const AKEYCODE_MUTE: ::std::os::raw::c_uint = 91;
pub const AKEYCODE_PAGE_UP: ::std::os::raw::c_uint = 92;
pub const AKEYCODE_PAGE_DOWN: ::std::os::raw::c_uint = 93;
pub const AKEYCODE_PICTSYMBOLS: ::std::os::raw::c_uint = 94;
pub const AKEYCODE_SWITCH_CHARSET: ::std::os::raw::c_uint = 95;
pub const AKEYCODE_BUTTON_A: ::std::os::raw::c_uint = 96;
pub const AKEYCODE_BUTTON_B: ::std::os::raw::c_uint = 97;
pub const AKEYCODE_BUTTON_C: ::std::os::raw::c_uint = 98;
pub const AKEYCODE_BUTTON_X: ::std::os::raw::c_uint = 99;
pub const AKEYCODE_BUTTON_Y: ::std::os::raw::c_uint = 100;
pub const AKEYCODE_BUTTON_Z: ::std::os::raw::c_uint = 101;
pub const AKEYCODE_BUTTON_L1: ::std::os::raw::c_uint = 102;
pub const AKEYCODE_BUTTON_R1: ::std::os::raw::c_uint = 103;
pub const AKEYCODE_BUTTON_L2: ::std::os::raw::c_uint = 104;
pub const AKEYCODE_BUTTON_R2: ::std::os::raw::c_uint = 105;
pub const AKEYCODE_BUTTON_THUMBL: ::std::os::raw::c_uint = 106;
pub const AKEYCODE_BUTTON_THUMBR: ::std::os::raw::c_uint = 107;
pub const AKEYCODE_BUTTON_START: ::std::os::raw::c_uint = 108;
pub const AKEYCODE_BUTTON_SELECT: ::std::os::raw::c_uint = 109;
pub const AKEYCODE_BUTTON_MODE: ::std::os::raw::c_uint = 110;
pub const AKEYCODE_ESCAPE: ::std::os::raw::c_uint = 111;
pub const AKEYCODE_FORWARD_DEL: ::std::os::raw::c_uint = 112;
pub const AKEYCODE_CTRL_LEFT: ::std::os::raw::c_uint = 113;
pub const AKEYCODE_CTRL_RIGHT: ::std::os::raw::c_uint = 114;
pub const AKEYCODE_CAPS_LOCK: ::std::os::raw::c_uint = 115;
pub const AKEYCODE_SCROLL_LOCK: ::std::os::raw::c_uint = 116;
pub const AKEYCODE_META_LEFT: ::std::os::raw::c_uint = 117;
pub const AKEYCODE_META_RIGHT: ::std::os::raw::c_uint = 118;
pub const AKEYCODE_FUNCTION: ::std::os::raw::c_uint = 119;
pub const AKEYCODE_SYSRQ: ::std::os::raw::c_uint = 120;
pub const AKEYCODE_BREAK: ::std::os::raw::c_uint = 121;
pub const AKEYCODE_MOVE_HOME: ::std::os::raw::c_uint = 122;
pub const AKEYCODE_MOVE_END: ::std::os::raw::c_uint = 123;
pub const AKEYCODE_INSERT: ::std::os::raw::c_uint = 124;
pub const AKEYCODE_FORWARD: ::std::os::raw::c_uint = 125;
pub const AKEYCODE_MEDIA_PLAY: ::std::os::raw::c_uint = 126;
pub const AKEYCODE_MEDIA_PAUSE: ::std::os::raw::c_uint = 127;
pub const AKEYCODE_MEDIA_CLOSE: ::std::os::raw::c_uint = 128;
pub const AKEYCODE_MEDIA_EJECT: ::std::os::raw::c_uint = 129;
pub const AKEYCODE_MEDIA_RECORD: ::std::os::raw::c_uint = 130;
pub const AKEYCODE_F1: ::std::os::raw::c_uint = 131;
pub const AKEYCODE_F2: ::std::os::raw::c_uint = 132;
pub const AKEYCODE_F3: ::std::os::raw::c_uint = 133;
pub const AKEYCODE_F4: ::std::os::raw::c_uint = 134;
pub const AKEYCODE_F5: ::std::os::raw::c_uint = 135;
pub const AKEYCODE_F6: ::std::os::raw::c_uint = 136;
pub const AKEYCODE_F7: ::std::os::raw::c_uint = 137;
pub const AKEYCODE_F8: ::std::os::raw::c_uint = 138;
pub const AKEYCODE_F9: ::std::os::raw::c_uint = 139;
pub const AKEYCODE_F10: ::std::os::raw::c_uint = 140;
pub const AKEYCODE_F11: ::std::os::raw::c_uint = 141;
pub const AKEYCODE_F12: ::std::os::raw::c_uint = 142;
pub const AKEYCODE_NUM_LOCK: ::std::os::raw::c_uint = 143;
pub const AKEYCODE_NUMPAD_0: ::std::os::raw::c_uint = 144;
pub const AKEYCODE_NUMPAD_1: ::std::os::raw::c_uint = 145;
pub const AKEYCODE_NUMPAD_2: ::std::os::raw::c_uint = 146;
pub const AKEYCODE_NUMPAD_3: ::std::os::raw::c_uint = 147;
pub const AKEYCODE_NUMPAD_4: ::std::os::raw::c_uint = 148;
pub const AKEYCODE_NUMPAD_5: ::std::os::raw::c_uint = 149;
pub const AKEYCODE_NUMPAD_6: ::std::os::raw::c_uint = 150;
pub const AKEYCODE_NUMPAD_7: ::std::os::raw::c_uint = 151;
pub const AKEYCODE_NUMPAD_8: ::std::os::raw::c_uint = 152;
pub const AKEYCODE_NUMPAD_9: ::std::os::raw::c_uint = 153;
pub const AKEYCODE_NUMPAD_DIVIDE: ::std::os::raw::c_uint = 154;
pub const AKEYCODE_NUMPAD_MULTIPLY: ::std::os::raw::c_uint = 155;
pub const AKEYCODE_NUMPAD_SUBTRACT: ::std::os::raw::c_uint = 156;
pub const AKEYCODE_NUMPAD_ADD: ::std::os::raw::c_uint = 157;
pub const AKEYCODE_NUMPAD_DOT: ::std::os::raw::c_uint = 158;
pub const AKEYCODE_NUMPAD_COMMA: ::std::os::raw::c_uint = 159;
pub const AKEYCODE_NUMPAD_ENTER: ::std::os::raw::c_uint = 160;
pub const AKEYCODE_NUMPAD_EQUALS: ::std::os::raw::c_uint = 161;
pub const AKEYCODE_NUMPAD_LEFT_PAREN: ::std::os::raw::c_uint = 162;
pub const AKEYCODE_NUMPAD_RIGHT_PAREN: ::std::os::raw::c_uint = 163;
pub const AKEYCODE_VOLUME_MUTE: ::std::os::raw::c_uint = 164;
pub const AKEYCODE_INFO: ::std::os::raw::c_uint = 165;
pub const AKEYCODE_CHANNEL_UP: ::std::os::raw::c_uint = 166;
pub const AKEYCODE_CHANNEL_DOWN: ::std::os::raw::c_uint = 167;
pub const AKEYCODE_ZOOM_IN: ::std::os::raw::c_uint = 168;
pub const AKEYCODE_ZOOM_OUT: ::std::os::raw::c_uint = 169;
pub const AKEYCODE_TV: ::std::os::raw::c_uint = 170;
pub const AKEYCODE_WINDOW: ::std::os::raw::c_uint = 171;
pub const AKEYCODE_GUIDE: ::std::os::raw::c_uint = 172;
pub const AKEYCODE_DVR: ::std::os::raw::c_uint = 173;
pub const AKEYCODE_BOOKMARK: ::std::os::raw::c_uint = 174;
pub const AKEYCODE_CAPTIONS: ::std::os::raw::c_uint = 175;
pub const AKEYCODE_SETTINGS: ::std::os::raw::c_uint = 176;
pub const AKEYCODE_TV_POWER: ::std::os::raw::c_uint = 177;
pub const AKEYCODE_TV_INPUT: ::std::os::raw::c_uint = 178;
pub const AKEYCODE_STB_POWER: ::std::os::raw::c_uint = 179;
pub const AKEYCODE_STB_INPUT: ::std::os::raw::c_uint = 180;
pub const AKEYCODE_AVR_POWER: ::std::os::raw::c_uint = 181;
pub const AKEYCODE_AVR_INPUT: ::std::os::raw::c_uint = 182;
pub const AKEYCODE_PROG_RED: ::std::os::raw::c_uint = 183;
pub const AKEYCODE_PROG_GREEN: ::std::os::raw::c_uint = 184;
pub const AKEYCODE_PROG_YELLOW: ::std::os::raw::c_uint = 185;
pub const AKEYCODE_PROG_BLUE: ::std::os::raw::c_uint = 186;
pub const AKEYCODE_APP_SWITCH: ::std::os::raw::c_uint = 187;
pub const AKEYCODE_BUTTON_1: ::std::os::raw::c_uint = 188;
pub const AKEYCODE_BUTTON_2: ::std::os::raw::c_uint = 189;
pub const AKEYCODE_BUTTON_3: ::std::os::raw::c_uint = 190;
pub const AKEYCODE_BUTTON_4: ::std::os::raw::c_uint = 191;
pub const AKEYCODE_BUTTON_5: ::std::os::raw::c_uint = 192;
pub const AKEYCODE_BUTTON_6: ::std::os::raw::c_uint = 193;
pub const AKEYCODE_BUTTON_7: ::std::os::raw::c_uint = 194;
pub const AKEYCODE_BUTTON_8: ::std::os::raw::c_uint = 195;
pub const AKEYCODE_BUTTON_9: ::std::os::raw::c_uint = 196;
pub const AKEYCODE_BUTTON_10: ::std::os::raw::c_uint = 197;
pub const AKEYCODE_BUTTON_11: ::std::os::raw::c_uint = 198;
pub const AKEYCODE_BUTTON_12: ::std::os::raw::c_uint = 199;
pub const AKEYCODE_BUTTON_13: ::std::os::raw::c_uint = 200;
pub const AKEYCODE_BUTTON_14: ::std::os::raw::c_uint = 201;
pub const AKEYCODE_BUTTON_15: ::std::os::raw::c_uint = 202;
pub const AKEYCODE_BUTTON_16: ::std::os::raw::c_uint = 203;
pub const AKEYCODE_LANGUAGE_SWITCH: ::std::os::raw::c_uint = 204;
pub const AKEYCODE_MANNER_MODE: ::std::os::raw::c_uint = 205;
pub const AKEYCODE_3D_MODE: ::std::os::raw::c_uint = 206;
pub const AKEYCODE_CONTACTS: ::std::os::raw::c_uint = 207;
pub const AKEYCODE_CALENDAR: ::std::os::raw::c_uint = 208;
pub const AKEYCODE_MUSIC: ::std::os::raw::c_uint = 209;
pub const AKEYCODE_CALCULATOR: ::std::os::raw::c_uint = 210;
pub const AKEYCODE_ZENKAKU_HANKAKU: ::std::os::raw::c_uint = 211;
pub const AKEYCODE_EISU: ::std::os::raw::c_uint = 212;
pub const AKEYCODE_MUHENKAN: ::std::os::raw::c_uint = 213;
pub const AKEYCODE_HENKAN: ::std::os::raw::c_uint = 214;
pub const AKEYCODE_KATAKANA_HIRAGANA: ::std::os::raw::c_uint = 215;
pub const AKEYCODE_YEN: ::std::os::raw::c_uint = 216;
pub const AKEYCODE_RO: ::std::os::raw::c_uint = 217;
pub const AKEYCODE_KANA: ::std::os::raw::c_uint = 218;
pub const AKEYCODE_ASSIST: ::std::os::raw::c_uint = 219;
pub const AKEYCODE_BRIGHTNESS_DOWN: ::std::os::raw::c_uint = 220;
pub const AKEYCODE_BRIGHTNESS_UP: ::std::os::raw::c_uint = 221;
pub const AKEYCODE_MEDIA_AUDIO_TRACK: ::std::os::raw::c_uint = 222;
pub const AKEYCODE_SLEEP: ::std::os::raw::c_uint = 223;
pub const AKEYCODE_WAKEUP: ::std::os::raw::c_uint = 224;
pub const AKEYCODE_PAIRING: ::std::os::raw::c_uint = 225;
pub const AKEYCODE_MEDIA_TOP_MENU: ::std::os::raw::c_uint = 226;
pub const AKEYCODE_11: ::std::os::raw::c_uint = 227;
pub const AKEYCODE_12: ::std::os::raw::c_uint = 228;
pub const AKEYCODE_LAST_CHANNEL: ::std::os::raw::c_uint = 229;
pub const AKEYCODE_TV_DATA_SERVICE: ::std::os::raw::c_uint = 230;
pub const AKEYCODE_VOICE_ASSIST: ::std::os::raw::c_uint = 231;
pub const AKEYCODE_TV_RADIO_SERVICE: ::std::os::raw::c_uint = 232;
pub const AKEYCODE_TV_TELETEXT: ::std::os::raw::c_uint = 233;
pub const AKEYCODE_TV_NUMBER_ENTRY: ::std::os::raw::c_uint = 234;
pub const AKEYCODE_TV_TERRESTRIAL_ANALOG: ::std::os::raw::c_uint = 235;
pub const AKEYCODE_TV_TERRESTRIAL_DIGITAL: ::std::os::raw::c_uint = 236;
pub const AKEYCODE_TV_SATELLITE: ::std::os::raw::c_uint = 237;
pub const AKEYCODE_TV_SATELLITE_BS: ::std::os::raw::c_uint = 238;
pub const AKEYCODE_TV_SATELLITE_CS: ::std::os::raw::c_uint = 239;
pub const AKEYCODE_TV_SATELLITE_SERVICE: ::std::os::raw::c_uint = 240;
pub const AKEYCODE_TV_NETWORK: ::std::os::raw::c_uint = 241;
pub const AKEYCODE_TV_ANTENNA_CABLE: ::std::os::raw::c_uint = 242;
pub const AKEYCODE_TV_INPUT_HDMI_1: ::std::os::raw::c_uint = 243;
pub const AKEYCODE_TV_INPUT_HDMI_2: ::std::os::raw::c_uint = 244;
pub const AKEYCODE_TV_INPUT_HDMI_3: ::std::os::raw::c_uint = 245;
pub const AKEYCODE_TV_INPUT_HDMI_4: ::std::os::raw::c_uint = 246;
pub const AKEYCODE_TV_INPUT_COMPOSITE_1: ::std::os::raw::c_uint = 247;
pub const AKEYCODE_TV_INPUT_COMPOSITE_2: ::std::os::raw::c_uint = 248;
pub const AKEYCODE_TV_INPUT_COMPONENT_1: ::std::os::raw::c_uint = 249;
pub const AKEYCODE_TV_INPUT_COMPONENT_2: ::std::os::raw::c_uint = 250;
pub const AKEYCODE_TV_INPUT_VGA_1: ::std::os::raw::c_uint = 251;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION: ::std::os::raw::c_uint = 252;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP: ::std::os::raw::c_uint = 253;
pub const AKEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN: ::std::os::raw::c_uint = 254;
pub const AKEYCODE_TV_ZOOM_MODE: ::std::os::raw::c_uint = 255;
pub const AKEYCODE_TV_CONTENTS_MENU: ::std::os::raw::c_uint = 256;
pub const AKEYCODE_TV_MEDIA_CONTEXT_MENU: ::std::os::raw::c_uint = 257;
pub const AKEYCODE_TV_TIMER_PROGRAMMING: ::std::os::raw::c_uint = 258;
pub const AKEYCODE_HELP: ::std::os::raw::c_uint = 259;
pub const AKEYCODE_NAVIGATE_PREVIOUS: ::std::os::raw::c_uint = 260;
pub const AKEYCODE_NAVIGATE_NEXT: ::std::os::raw::c_uint = 261;
pub const AKEYCODE_NAVIGATE_IN: ::std::os::raw::c_uint = 262;
pub const AKEYCODE_NAVIGATE_OUT: ::std::os::raw::c_uint = 263;
pub const AKEYCODE_STEM_PRIMARY: ::std::os::raw::c_uint = 264;
pub const AKEYCODE_STEM_1: ::std::os::raw::c_uint = 265;
pub const AKEYCODE_STEM_2: ::std::os::raw::c_uint = 266;
pub const AKEYCODE_STEM_3: ::std::os::raw::c_uint = 267;
pub const AKEYCODE_DPAD_UP_LEFT: ::std::os::raw::c_uint = 268;
pub const AKEYCODE_DPAD_DOWN_LEFT: ::std::os::raw::c_uint = 269;
pub const AKEYCODE_DPAD_UP_RIGHT: ::std::os::raw::c_uint = 270;
pub const AKEYCODE_DPAD_DOWN_RIGHT: ::std::os::raw::c_uint = 271;
pub const AKEYCODE_MEDIA_SKIP_FORWARD: ::std::os::raw::c_uint = 272;
pub const AKEYCODE_MEDIA_SKIP_BACKWARD: ::std::os::raw::c_uint = 273;
pub const AKEYCODE_MEDIA_STEP_FORWARD: ::std::os::raw::c_uint = 274;
pub const AKEYCODE_MEDIA_STEP_BACKWARD: ::std::os::raw::c_uint = 275;
pub const AKEYCODE_SOFT_SLEEP: ::std::os::raw::c_uint = 276;
pub const AKEYCODE_CUT: ::std::os::raw::c_uint = 277;
pub const AKEYCODE_COPY: ::std::os::raw::c_uint = 278;
pub const AKEYCODE_PASTE: ::std::os::raw::c_uint = 279;
pub const AKEYCODE_SYSTEM_NAVIGATION_UP: ::std::os::raw::c_uint = 280;
pub const AKEYCODE_SYSTEM_NAVIGATION_DOWN: ::std::os::raw::c_uint = 281;
pub const AKEYCODE_SYSTEM_NAVIGATION_LEFT: ::std::os::raw::c_uint = 282;
pub const AKEYCODE_SYSTEM_NAVIGATION_RIGHT: ::std::os::raw::c_uint = 283;
pub const AKEYCODE_ALL_APPS: ::std::os::raw::c_uint = 284;
pub const AKEYCODE_REFRESH: ::std::os::raw::c_uint = 285;
pub const AKEYCODE_THUMBS_UP: ::std::os::raw::c_uint = 286;
pub const AKEYCODE_THUMBS_DOWN: ::std::os::raw::c_uint = 287;
pub const AKEYCODE_PROFILE_SWITCH: ::std::os::raw::c_uint = 288;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const ALOOPER_PREPARE_ALLOW_NON_CALLBACKS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const ALOOPER_POLL_WAKE: ::std::os::raw::c_int = -1;
pub const ALOOPER_POLL_CALLBACK: ::std::os::raw::c_int = -2;
pub const ALOOPER_POLL_TIMEOUT: ::std::os::raw::c_int = -3;
pub const ALOOPER_POLL_ERROR: ::std::os::raw::c_int = -4;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub const ALOOPER_EVENT_INPUT: ::std::os::raw::c_uint = 1;
pub const ALOOPER_EVENT_OUTPUT: ::std::os::raw::c_uint = 2;
pub const ALOOPER_EVENT_ERROR: ::std::os::raw::c_uint = 4;
pub const ALOOPER_EVENT_HANGUP: ::std::os::raw::c_uint = 8;
pub const ALOOPER_EVENT_INVALID: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const AKEY_STATE_UNKNOWN: ::std::os::raw::c_int = -1;
pub const AKEY_STATE_UP: ::std::os::raw::c_int = 0;
pub const AKEY_STATE_DOWN: ::std::os::raw::c_int = 1;
pub const AKEY_STATE_VIRTUAL: ::std::os::raw::c_int = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
pub const AMETA_NONE: ::std::os::raw::c_uint = 0;
pub const AMETA_ALT_ON: ::std::os::raw::c_uint = 2;
pub const AMETA_ALT_LEFT_ON: ::std::os::raw::c_uint = 16;
pub const AMETA_ALT_RIGHT_ON: ::std::os::raw::c_uint = 32;
pub const AMETA_SHIFT_ON: ::std::os::raw::c_uint = 1;
pub const AMETA_SHIFT_LEFT_ON: ::std::os::raw::c_uint = 64;
pub const AMETA_SHIFT_RIGHT_ON: ::std::os::raw::c_uint = 128;
pub const AMETA_SYM_ON: ::std::os::raw::c_uint = 4;
pub const AMETA_FUNCTION_ON: ::std::os::raw::c_uint = 8;
pub const AMETA_CTRL_ON: ::std::os::raw::c_uint = 4096;
pub const AMETA_CTRL_LEFT_ON: ::std::os::raw::c_uint = 8192;
pub const AMETA_CTRL_RIGHT_ON: ::std::os::raw::c_uint = 16384;
pub const AMETA_META_ON: ::std::os::raw::c_uint = 65536;
pub const AMETA_META_LEFT_ON: ::std::os::raw::c_uint = 131072;
pub const AMETA_META_RIGHT_ON: ::std::os::raw::c_uint = 262144;
pub const AMETA_CAPS_LOCK_ON: ::std::os::raw::c_uint = 1048576;
pub const AMETA_NUM_LOCK_ON: ::std::os::raw::c_uint = 2097152;
pub const AMETA_SCROLL_LOCK_ON: ::std::os::raw::c_uint = 4194304;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AInputEvent {
    _unused: [u8; 0],
}
pub const AINPUT_EVENT_TYPE_KEY: ::std::os::raw::c_uint = 1;
pub const AINPUT_EVENT_TYPE_MOTION: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const AKEY_EVENT_ACTION_DOWN: ::std::os::raw::c_uint = 0;
pub const AKEY_EVENT_ACTION_UP: ::std::os::raw::c_uint = 1;
pub const AKEY_EVENT_ACTION_MULTIPLE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const AKEY_EVENT_FLAG_WOKE_HERE: ::std::os::raw::c_uint = 1;
pub const AKEY_EVENT_FLAG_SOFT_KEYBOARD: ::std::os::raw::c_uint = 2;
pub const AKEY_EVENT_FLAG_KEEP_TOUCH_MODE: ::std::os::raw::c_uint = 4;
pub const AKEY_EVENT_FLAG_FROM_SYSTEM: ::std::os::raw::c_uint = 8;
pub const AKEY_EVENT_FLAG_EDITOR_ACTION: ::std::os::raw::c_uint = 16;
pub const AKEY_EVENT_FLAG_CANCELED: ::std::os::raw::c_uint = 32;
pub const AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY: ::std::os::raw::c_uint = 64;
pub const AKEY_EVENT_FLAG_LONG_PRESS: ::std::os::raw::c_uint = 128;
pub const AKEY_EVENT_FLAG_CANCELED_LONG_PRESS: ::std::os::raw::c_uint = 256;
pub const AKEY_EVENT_FLAG_TRACKING: ::std::os::raw::c_uint = 512;
pub const AKEY_EVENT_FLAG_FALLBACK: ::std::os::raw::c_uint = 1024;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_ACTION_MASK: ::std::os::raw::c_uint = 255;
pub const AMOTION_EVENT_ACTION_POINTER_INDEX_MASK: ::std::os::raw::c_uint = 65280;
pub const AMOTION_EVENT_ACTION_DOWN: ::std::os::raw::c_uint = 0;
pub const AMOTION_EVENT_ACTION_UP: ::std::os::raw::c_uint = 1;
pub const AMOTION_EVENT_ACTION_MOVE: ::std::os::raw::c_uint = 2;
pub const AMOTION_EVENT_ACTION_CANCEL: ::std::os::raw::c_uint = 3;
pub const AMOTION_EVENT_ACTION_OUTSIDE: ::std::os::raw::c_uint = 4;
pub const AMOTION_EVENT_ACTION_POINTER_DOWN: ::std::os::raw::c_uint = 5;
pub const AMOTION_EVENT_ACTION_POINTER_UP: ::std::os::raw::c_uint = 6;
pub const AMOTION_EVENT_ACTION_HOVER_MOVE: ::std::os::raw::c_uint = 7;
pub const AMOTION_EVENT_ACTION_SCROLL: ::std::os::raw::c_uint = 8;
pub const AMOTION_EVENT_ACTION_HOVER_ENTER: ::std::os::raw::c_uint = 9;
pub const AMOTION_EVENT_ACTION_HOVER_EXIT: ::std::os::raw::c_uint = 10;
pub const AMOTION_EVENT_ACTION_BUTTON_PRESS: ::std::os::raw::c_uint = 11;
pub const AMOTION_EVENT_ACTION_BUTTON_RELEASE: ::std::os::raw::c_uint = 12;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_EDGE_FLAG_NONE: ::std::os::raw::c_uint = 0;
pub const AMOTION_EVENT_EDGE_FLAG_TOP: ::std::os::raw::c_uint = 1;
pub const AMOTION_EVENT_EDGE_FLAG_BOTTOM: ::std::os::raw::c_uint = 2;
pub const AMOTION_EVENT_EDGE_FLAG_LEFT: ::std::os::raw::c_uint = 4;
pub const AMOTION_EVENT_EDGE_FLAG_RIGHT: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_AXIS_X: ::std::os::raw::c_uint = 0;
pub const AMOTION_EVENT_AXIS_Y: ::std::os::raw::c_uint = 1;
pub const AMOTION_EVENT_AXIS_PRESSURE: ::std::os::raw::c_uint = 2;
pub const AMOTION_EVENT_AXIS_SIZE: ::std::os::raw::c_uint = 3;
pub const AMOTION_EVENT_AXIS_TOUCH_MAJOR: ::std::os::raw::c_uint = 4;
pub const AMOTION_EVENT_AXIS_TOUCH_MINOR: ::std::os::raw::c_uint = 5;
pub const AMOTION_EVENT_AXIS_TOOL_MAJOR: ::std::os::raw::c_uint = 6;
pub const AMOTION_EVENT_AXIS_TOOL_MINOR: ::std::os::raw::c_uint = 7;
pub const AMOTION_EVENT_AXIS_ORIENTATION: ::std::os::raw::c_uint = 8;
pub const AMOTION_EVENT_AXIS_VSCROLL: ::std::os::raw::c_uint = 9;
pub const AMOTION_EVENT_AXIS_HSCROLL: ::std::os::raw::c_uint = 10;
pub const AMOTION_EVENT_AXIS_Z: ::std::os::raw::c_uint = 11;
pub const AMOTION_EVENT_AXIS_RX: ::std::os::raw::c_uint = 12;
pub const AMOTION_EVENT_AXIS_RY: ::std::os::raw::c_uint = 13;
pub const AMOTION_EVENT_AXIS_RZ: ::std::os::raw::c_uint = 14;
pub const AMOTION_EVENT_AXIS_HAT_X: ::std::os::raw::c_uint = 15;
pub const AMOTION_EVENT_AXIS_HAT_Y: ::std::os::raw::c_uint = 16;
pub const AMOTION_EVENT_AXIS_LTRIGGER: ::std::os::raw::c_uint = 17;
pub const AMOTION_EVENT_AXIS_RTRIGGER: ::std::os::raw::c_uint = 18;
pub const AMOTION_EVENT_AXIS_THROTTLE: ::std::os::raw::c_uint = 19;
pub const AMOTION_EVENT_AXIS_RUDDER: ::std::os::raw::c_uint = 20;
pub const AMOTION_EVENT_AXIS_WHEEL: ::std::os::raw::c_uint = 21;
pub const AMOTION_EVENT_AXIS_GAS: ::std::os::raw::c_uint = 22;
pub const AMOTION_EVENT_AXIS_BRAKE: ::std::os::raw::c_uint = 23;
pub const AMOTION_EVENT_AXIS_DISTANCE: ::std::os::raw::c_uint = 24;
pub const AMOTION_EVENT_AXIS_TILT: ::std::os::raw::c_uint = 25;
pub const AMOTION_EVENT_AXIS_SCROLL: ::std::os::raw::c_uint = 26;
pub const AMOTION_EVENT_AXIS_RELATIVE_X: ::std::os::raw::c_uint = 27;
pub const AMOTION_EVENT_AXIS_RELATIVE_Y: ::std::os::raw::c_uint = 28;
pub const AMOTION_EVENT_AXIS_GENERIC_1: ::std::os::raw::c_uint = 32;
pub const AMOTION_EVENT_AXIS_GENERIC_2: ::std::os::raw::c_uint = 33;
pub const AMOTION_EVENT_AXIS_GENERIC_3: ::std::os::raw::c_uint = 34;
pub const AMOTION_EVENT_AXIS_GENERIC_4: ::std::os::raw::c_uint = 35;
pub const AMOTION_EVENT_AXIS_GENERIC_5: ::std::os::raw::c_uint = 36;
pub const AMOTION_EVENT_AXIS_GENERIC_6: ::std::os::raw::c_uint = 37;
pub const AMOTION_EVENT_AXIS_GENERIC_7: ::std::os::raw::c_uint = 38;
pub const AMOTION_EVENT_AXIS_GENERIC_8: ::std::os::raw::c_uint = 39;
pub const AMOTION_EVENT_AXIS_GENERIC_9: ::std::os::raw::c_uint = 40;
pub const AMOTION_EVENT_AXIS_GENERIC_10: ::std::os::raw::c_uint = 41;
pub const AMOTION_EVENT_AXIS_GENERIC_11: ::std::os::raw::c_uint = 42;
pub const AMOTION_EVENT_AXIS_GENERIC_12: ::std::os::raw::c_uint = 43;
pub const AMOTION_EVENT_AXIS_GENERIC_13: ::std::os::raw::c_uint = 44;
pub const AMOTION_EVENT_AXIS_GENERIC_14: ::std::os::raw::c_uint = 45;
pub const AMOTION_EVENT_AXIS_GENERIC_15: ::std::os::raw::c_uint = 46;
pub const AMOTION_EVENT_AXIS_GENERIC_16: ::std::os::raw::c_uint = 47;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_BUTTON_PRIMARY: ::std::os::raw::c_uint = 1;
pub const AMOTION_EVENT_BUTTON_SECONDARY: ::std::os::raw::c_uint = 2;
pub const AMOTION_EVENT_BUTTON_TERTIARY: ::std::os::raw::c_uint = 4;
pub const AMOTION_EVENT_BUTTON_BACK: ::std::os::raw::c_uint = 8;
pub const AMOTION_EVENT_BUTTON_FORWARD: ::std::os::raw::c_uint = 16;
pub const AMOTION_EVENT_BUTTON_STYLUS_PRIMARY: ::std::os::raw::c_uint = 32;
pub const AMOTION_EVENT_BUTTON_STYLUS_SECONDARY: ::std::os::raw::c_uint = 64;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const AMOTION_EVENT_TOOL_TYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const AMOTION_EVENT_TOOL_TYPE_FINGER: ::std::os::raw::c_uint = 1;
pub const AMOTION_EVENT_TOOL_TYPE_STYLUS: ::std::os::raw::c_uint = 2;
pub const AMOTION_EVENT_TOOL_TYPE_MOUSE: ::std::os::raw::c_uint = 3;
pub const AMOTION_EVENT_TOOL_TYPE_ERASER: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const AINPUT_SOURCE_CLASS_MASK: ::std::os::raw::c_uint = 255;
pub const AINPUT_SOURCE_CLASS_NONE: ::std::os::raw::c_uint = 0;
pub const AINPUT_SOURCE_CLASS_BUTTON: ::std::os::raw::c_uint = 1;
pub const AINPUT_SOURCE_CLASS_POINTER: ::std::os::raw::c_uint = 2;
pub const AINPUT_SOURCE_CLASS_NAVIGATION: ::std::os::raw::c_uint = 4;
pub const AINPUT_SOURCE_CLASS_POSITION: ::std::os::raw::c_uint = 8;
pub const AINPUT_SOURCE_CLASS_JOYSTICK: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const AINPUT_SOURCE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const AINPUT_SOURCE_KEYBOARD: ::std::os::raw::c_uint = 257;
pub const AINPUT_SOURCE_DPAD: ::std::os::raw::c_uint = 513;
pub const AINPUT_SOURCE_GAMEPAD: ::std::os::raw::c_uint = 1025;
pub const AINPUT_SOURCE_TOUCHSCREEN: ::std::os::raw::c_uint = 4098;
pub const AINPUT_SOURCE_MOUSE: ::std::os::raw::c_uint = 8194;
pub const AINPUT_SOURCE_STYLUS: ::std::os::raw::c_uint = 16386;
pub const AINPUT_SOURCE_BLUETOOTH_STYLUS: ::std::os::raw::c_uint = 49154;
pub const AINPUT_SOURCE_TRACKBALL: ::std::os::raw::c_uint = 65540;
pub const AINPUT_SOURCE_MOUSE_RELATIVE: ::std::os::raw::c_uint = 131076;
pub const AINPUT_SOURCE_TOUCHPAD: ::std::os::raw::c_uint = 1048584;
pub const AINPUT_SOURCE_TOUCH_NAVIGATION: ::std::os::raw::c_uint = 2097152;
pub const AINPUT_SOURCE_JOYSTICK: ::std::os::raw::c_uint = 16777232;
pub const AINPUT_SOURCE_ROTARY_ENCODER: ::std::os::raw::c_uint = 4194304;
pub const AINPUT_SOURCE_ANY: ::std::os::raw::c_uint = 4294967040;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const AINPUT_KEYBOARD_TYPE_NONE: ::std::os::raw::c_uint = 0;
pub const AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC: ::std::os::raw::c_uint = 1;
pub const AINPUT_KEYBOARD_TYPE_ALPHABETIC: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const AINPUT_MOTION_RANGE_X: ::std::os::raw::c_uint = 0;
pub const AINPUT_MOTION_RANGE_Y: ::std::os::raw::c_uint = 1;
pub const AINPUT_MOTION_RANGE_PRESSURE: ::std::os::raw::c_uint = 2;
pub const AINPUT_MOTION_RANGE_SIZE: ::std::os::raw::c_uint = 3;
pub const AINPUT_MOTION_RANGE_TOUCH_MAJOR: ::std::os::raw::c_uint = 4;
pub const AINPUT_MOTION_RANGE_TOUCH_MINOR: ::std::os::raw::c_uint = 5;
pub const AINPUT_MOTION_RANGE_TOOL_MAJOR: ::std::os::raw::c_uint = 6;
pub const AINPUT_MOTION_RANGE_TOOL_MINOR: ::std::os::raw::c_uint = 7;
pub const AINPUT_MOTION_RANGE_ORIENTATION: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn AInputEvent_getType(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputEvent_getDeviceId(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputEvent_getSource(event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getAction(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getFlags(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getKeyCode(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getScanCode(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getMetaState(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getRepeatCount(key_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AKeyEvent_getDownTime(key_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AKeyEvent_getEventTime(key_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getAction(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getFlags(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getMetaState(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getButtonState(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getEdgeFlags(motion_event: *const AInputEvent) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getDownTime(motion_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getEventTime(motion_event: *const AInputEvent) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getXOffset(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getYOffset(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getXPrecision(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getYPrecision(motion_event: *const AInputEvent) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getPointerCount(motion_event: *const AInputEvent) -> size_t;
}
extern "C" {
    pub fn AMotionEvent_getPointerId(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> i32;
}
extern "C" {
    pub fn AMotionEvent_getToolType(motion_event: *const AInputEvent, pointer_index: size_t)
        -> i32;
}
extern "C" {
    pub fn AMotionEvent_getRawX(motion_event: *const AInputEvent, pointer_index: size_t) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getRawY(motion_event: *const AInputEvent, pointer_index: size_t) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getX(motion_event: *const AInputEvent, pointer_index: size_t) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getY(motion_event: *const AInputEvent, pointer_index: size_t) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getPressure(motion_event: *const AInputEvent, pointer_index: size_t)
        -> f32;
}
extern "C" {
    pub fn AMotionEvent_getSize(motion_event: *const AInputEvent, pointer_index: size_t) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getTouchMajor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getTouchMinor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getToolMajor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getToolMinor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getOrientation(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getAxisValue(
        motion_event: *const AInputEvent,
        axis: i32,
        pointer_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistorySize(motion_event: *const AInputEvent) -> size_t;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalEventTime(
        motion_event: *const AInputEvent,
        history_index: size_t,
    ) -> i64;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalRawX(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalRawY(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalX(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalY(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalPressure(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalSize(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalTouchMajor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalTouchMinor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalToolMajor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalToolMinor(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalOrientation(
        motion_event: *const AInputEvent,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
extern "C" {
    pub fn AMotionEvent_getHistoricalAxisValue(
        motion_event: *const AInputEvent,
        axis: i32,
        pointer_index: size_t,
        history_index: size_t,
    ) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AInputQueue {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AInputQueue_attachLooper(
        queue: *mut AInputQueue,
        looper: *mut ALooper,
        ident: ::std::os::raw::c_int,
        callback: ALooper_callbackFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn AInputQueue_detachLooper(queue: *mut AInputQueue);
}
extern "C" {
    pub fn AInputQueue_hasEvents(queue: *mut AInputQueue) -> i32;
}
extern "C" {
    pub fn AInputQueue_getEvent(queue: *mut AInputQueue, outEvent: *mut *mut AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputQueue_preDispatchEvent(queue: *mut AInputQueue, event: *mut AInputEvent) -> i32;
}
extern "C" {
    pub fn AInputQueue_finishEvent(
        queue: *mut AInputQueue,
        event: *mut AInputEvent,
        handled: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__i: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numerator: intmax_t, __denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __s: *const wchar_t,
        __end_ptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const ADataSpace_ADATASPACE_UNKNOWN: ADataSpace = 0;
pub const ADataSpace_ADATASPACE_SCRGB_LINEAR: ADataSpace = 406913024;
pub const ADataSpace_ADATASPACE_SRGB: ADataSpace = 142671872;
pub const ADataSpace_ADATASPACE_SCRGB: ADataSpace = 411107328;
pub const ADataSpace_ADATASPACE_DISPLAY_P3: ADataSpace = 143261696;
pub const ADataSpace_ADATASPACE_BT2020_PQ: ADataSpace = 163971072;
pub type ADataSpace = ::std::os::raw::c_uint;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM: AHardwareBuffer_Format = 1;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM: AHardwareBuffer_Format = 2;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM: AHardwareBuffer_Format = 3;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM: AHardwareBuffer_Format = 4;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT: AHardwareBuffer_Format =
    22;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_R10G10B10A2_UNORM: AHardwareBuffer_Format =
    43;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_BLOB: AHardwareBuffer_Format = 33;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_D16_UNORM: AHardwareBuffer_Format = 48;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_D24_UNORM: AHardwareBuffer_Format = 49;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_D24_UNORM_S8_UINT: AHardwareBuffer_Format =
    50;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_D32_FLOAT: AHardwareBuffer_Format = 51;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_D32_FLOAT_S8_UINT: AHardwareBuffer_Format =
    52;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_S8_UINT: AHardwareBuffer_Format = 53;
pub const AHardwareBuffer_Format_AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_420: AHardwareBuffer_Format = 35;
pub type AHardwareBuffer_Format = ::std::os::raw::c_uint;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_READ_NEVER:
    AHardwareBuffer_UsageFlags = 0;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_READ_RARELY:
    AHardwareBuffer_UsageFlags = 2;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_READ_OFTEN:
    AHardwareBuffer_UsageFlags = 3;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_READ_MASK:
    AHardwareBuffer_UsageFlags = 15;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_WRITE_NEVER:
    AHardwareBuffer_UsageFlags = 0;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_WRITE_RARELY:
    AHardwareBuffer_UsageFlags = 32;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_WRITE_OFTEN:
    AHardwareBuffer_UsageFlags = 48;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_CPU_WRITE_MASK:
    AHardwareBuffer_UsageFlags = 240;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE:
    AHardwareBuffer_UsageFlags = 256;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER:
    AHardwareBuffer_UsageFlags = 512;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT:
    AHardwareBuffer_UsageFlags = 512;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_COMPOSER_OVERLAY:
    AHardwareBuffer_UsageFlags = 2048;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_PROTECTED_CONTENT:
    AHardwareBuffer_UsageFlags = 16384;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VIDEO_ENCODE:
    AHardwareBuffer_UsageFlags = 65536;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_SENSOR_DIRECT_DATA:
    AHardwareBuffer_UsageFlags = 8388608;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER:
    AHardwareBuffer_UsageFlags = 16777216;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_CUBE_MAP:
    AHardwareBuffer_UsageFlags = 33554432;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE:
    AHardwareBuffer_UsageFlags = 67108864;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_0: AHardwareBuffer_UsageFlags =
    268435456;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_1: AHardwareBuffer_UsageFlags =
    536870912;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_2: AHardwareBuffer_UsageFlags =
    1073741824;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_3: AHardwareBuffer_UsageFlags =
    2147483648;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_4: AHardwareBuffer_UsageFlags =
    281474976710656;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_5: AHardwareBuffer_UsageFlags =
    562949953421312;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_6: AHardwareBuffer_UsageFlags =
    1125899906842624;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_7: AHardwareBuffer_UsageFlags =
    2251799813685248;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_8: AHardwareBuffer_UsageFlags =
    4503599627370496;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_9: AHardwareBuffer_UsageFlags =
    9007199254740992;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_10: AHardwareBuffer_UsageFlags =
    18014398509481984;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_11: AHardwareBuffer_UsageFlags =
    36028797018963968;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_12: AHardwareBuffer_UsageFlags =
    72057594037927936;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_13: AHardwareBuffer_UsageFlags =
    144115188075855872;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_14: AHardwareBuffer_UsageFlags =
    288230376151711744;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_15: AHardwareBuffer_UsageFlags =
    576460752303423488;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_16: AHardwareBuffer_UsageFlags =
    1152921504606846976;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_17: AHardwareBuffer_UsageFlags =
    2305843009213693952;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_18: AHardwareBuffer_UsageFlags =
    4611686018427387904;
pub const AHardwareBuffer_UsageFlags_AHARDWAREBUFFER_USAGE_VENDOR_19: AHardwareBuffer_UsageFlags =
    9223372036854775808;
pub type AHardwareBuffer_UsageFlags = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Desc {
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    pub format: u32,
    pub usage: u64,
    pub stride: u32,
    pub rfu0: u32,
    pub rfu1: u64,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Desc() {
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Desc>(),
        40usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Desc>(),
        4usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).layers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).stride as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).rfu0 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).rfu1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Plane {
    pub data: *mut ::std::os::raw::c_void,
    pub pixelStride: u32,
    pub rowStride: u32,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Plane() {
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Plane>(),
        12usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Plane>(),
        4usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Plane>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AHardwareBuffer_Plane>())).pixelStride as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(pixelStride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Plane>())).rowStride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(rowStride)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Planes {
    pub planeCount: u32,
    pub planes: [AHardwareBuffer_Plane; 4usize],
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Planes() {
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Planes>(),
        52usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Planes>(),
        4usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AHardwareBuffer_Planes>())).planeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Planes>())).planes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AHardwareBuffer_allocate(
        desc: *const AHardwareBuffer_Desc,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_acquire(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_release(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_describe(
        buffer: *const AHardwareBuffer,
        outDesc: *mut AHardwareBuffer_Desc,
    );
}
extern "C" {
    pub fn AHardwareBuffer_lock(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockPlanes(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outPlanes: *mut AHardwareBuffer_Planes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_unlock(
        buffer: *mut AHardwareBuffer,
        fence: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_sendHandleToUnixSocket(
        buffer: *const AHardwareBuffer,
        socketFd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_recvHandleFromUnixSocket(
        socketFd: ::std::os::raw::c_int,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_isSupported(desc: *const AHardwareBuffer_Desc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockAndGetInfo(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
        outBytesPerPixel: *mut i32,
        outBytesPerStride: *mut i32,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
pub struct JavaVMAttachArgs {
    pub version: jint,
    pub name: *const ::std::os::raw::c_char,
    pub group: jobject,
}
#[test]
fn bindgen_test_layout_JavaVMAttachArgs() {
    assert_eq!(
        ::std::mem::size_of::<JavaVMAttachArgs>(),
        12usize,
        concat!("Size of: ", stringify!(JavaVMAttachArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMAttachArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(JavaVMAttachArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMAttachArgs>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMAttachArgs>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMAttachArgs>())).group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMAttachArgs),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JavaVMOption {
    pub optionString: *const ::std::os::raw::c_char,
    pub extraInfo: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_JavaVMOption() {
    assert_eq!(
        ::std::mem::size_of::<JavaVMOption>(),
        8usize,
        concat!("Size of: ", stringify!(JavaVMOption))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMOption>(),
        4usize,
        concat!("Alignment of ", stringify!(JavaVMOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMOption>())).optionString as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMOption),
            "::",
            stringify!(optionString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMOption>())).extraInfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMOption),
            "::",
            stringify!(extraInfo)
        )
    );
}
#[repr(C)]
pub struct JavaVMInitArgs {
    pub version: jint,
    pub nOptions: jint,
    pub options: *mut JavaVMOption,
    pub ignoreUnrecognized: jboolean,
}
#[test]
fn bindgen_test_layout_JavaVMInitArgs() {
    assert_eq!(
        ::std::mem::size_of::<JavaVMInitArgs>(),
        16usize,
        concat!("Size of: ", stringify!(JavaVMInitArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<JavaVMInitArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(JavaVMInitArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMInitArgs>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMInitArgs>())).nOptions as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(nOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JavaVMInitArgs>())).options as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JavaVMInitArgs>())).ignoreUnrecognized as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JavaVMInitArgs),
            "::",
            stringify!(ignoreUnrecognized)
        )
    );
}
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_CAPTION_BAR: GameCommonInsetsType = 0;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_DISPLAY_CUTOUT: GameCommonInsetsType = 1;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_IME: GameCommonInsetsType = 2;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_MANDATORY_SYSTEM_GESTURES:
    GameCommonInsetsType = 3;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_NAVIGATION_BARS: GameCommonInsetsType = 4;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_STATUS_BARS: GameCommonInsetsType = 5;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_SYSTEM_BARS: GameCommonInsetsType = 6;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_SYSTEM_GESTURES: GameCommonInsetsType = 7;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_TAPABLE_ELEMENT: GameCommonInsetsType = 8;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_WATERFALL: GameCommonInsetsType = 9;
pub const GameCommonInsetsType_GAMECOMMON_INSETS_TYPE_COUNT: GameCommonInsetsType = 10;
#[doc = " The type of a component for which to retrieve insets. See"]
#[doc = " https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.Type"]
pub type GameCommonInsetsType = ::std::os::raw::c_uint;
#[doc = " This struct holds a span within a region of text from start (inclusive) to"]
#[doc = " end (exclusive). An empty span or cursor position is specified with"]
#[doc = " start==end. An undefined span is specified with start = end = SPAN_UNDEFINED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameTextInputSpan {
    #[doc = " The start of the region (inclusive)."]
    pub start: i32,
    #[doc = " The end of the region (exclusive)."]
    pub end: i32,
}
#[test]
fn bindgen_test_layout_GameTextInputSpan() {
    assert_eq!(
        ::std::mem::size_of::<GameTextInputSpan>(),
        8usize,
        concat!("Size of: ", stringify!(GameTextInputSpan))
    );
    assert_eq!(
        ::std::mem::align_of::<GameTextInputSpan>(),
        4usize,
        concat!("Alignment of ", stringify!(GameTextInputSpan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameTextInputSpan>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputSpan),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameTextInputSpan>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputSpan),
            "::",
            stringify!(end)
        )
    );
}
pub const GameTextInputSpanFlag_SPAN_UNDEFINED: GameTextInputSpanFlag = -1;
#[doc = " Values with special meaning in a GameTextInputSpan."]
pub type GameTextInputSpanFlag = ::std::os::raw::c_int;
#[doc = " This struct holds the state of an editable section of text."]
#[doc = " The text can have a selection and a composing region defined on it."]
#[doc = " A composing region is used by IMEs that allow input using multiple steps to"]
#[doc = " compose a glyph or word. Use functions GameTextInput_getState and"]
#[doc = " GameTextInput_setState to read and modify the state that an IME is editing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameTextInputState {
    #[doc = " Text owned by the state, as a modified UTF-8 string. Null-terminated."]
    #[doc = " https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8"]
    pub text_UTF8: *const ::std::os::raw::c_char,
    #[doc = " Length in bytes of text_UTF8, *not* including the null at end."]
    pub text_length: i32,
    #[doc = " A selection defined on the text."]
    pub selection: GameTextInputSpan,
    #[doc = " A composing region defined on the text."]
    pub composingRegion: GameTextInputSpan,
}
#[test]
fn bindgen_test_layout_GameTextInputState() {
    assert_eq!(
        ::std::mem::size_of::<GameTextInputState>(),
        24usize,
        concat!("Size of: ", stringify!(GameTextInputState))
    );
    assert_eq!(
        ::std::mem::align_of::<GameTextInputState>(),
        4usize,
        concat!("Alignment of ", stringify!(GameTextInputState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameTextInputState>())).text_UTF8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputState),
            "::",
            stringify!(text_UTF8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameTextInputState>())).text_length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputState),
            "::",
            stringify!(text_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameTextInputState>())).selection as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputState),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameTextInputState>())).composingRegion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameTextInputState),
            "::",
            stringify!(composingRegion)
        )
    );
}
#[doc = " A callback called by GameTextInput_getState."]
#[doc = " @param context User-defined context."]
#[doc = " @param state State, owned by the library, that will be valid for the duration"]
#[doc = " of the callback."]
pub type GameTextInputGetStateCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, state: *const GameTextInputState),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameTextInput {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialize the GameTextInput library."]
    #[doc = " If called twice without GameTextInput_destroy being called, the same pointer"]
    #[doc = " will be returned and a warning will be issued."]
    #[doc = " @param env A JNI env valid on the calling thread."]
    #[doc = " @param max_string_size The maximum length of a string that can be edited. If"]
    #[doc = " zero, the maximum defaults to 65536 bytes. A buffer of this size is allocated"]
    #[doc = " at initialization."]
    #[doc = " @return A handle to the library."]
    pub fn GameTextInput_init(env: *mut JNIEnv, max_string_size: u32) -> *mut GameTextInput;
}
extern "C" {
    #[doc = " When using GameTextInput, you need to create a gametextinput.InputConnection"]
    #[doc = " on the Java side and pass it using this function to the library, unless using"]
    #[doc = " GameActivity in which case this will be done for you. See the GameActivity"]
    #[doc = " source code or GameTextInput samples for examples of usage."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param inputConnection A gametextinput.InputConnection object."]
    pub fn GameTextInput_setInputConnection(input: *mut GameTextInput, inputConnection: jobject);
}
extern "C" {
    #[doc = " Unless using GameActivity, it is required to call this function from your"]
    #[doc = " Java gametextinput.Listener.stateChanged method to convert eventState and"]
    #[doc = " trigger any event callbacks. When using GameActivity, this does not need to"]
    #[doc = " be called as event processing is handled by the Activity."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param eventState A Java gametextinput.State object."]
    pub fn GameTextInput_processEvent(input: *mut GameTextInput, eventState: jobject);
}
extern "C" {
    #[doc = " Free any resources owned by the GameTextInput library."]
    #[doc = " Any subsequent calls to the library will fail until GameTextInput_init is"]
    #[doc = " called again."]
    #[doc = " @param input A valid GameTextInput library handle."]
    pub fn GameTextInput_destroy(input: *mut GameTextInput);
}
pub const ShowImeFlags_SHOW_IME_UNDEFINED: ShowImeFlags = 0;
pub const ShowImeFlags_SHOW_IMPLICIT: ShowImeFlags = 1;
pub const ShowImeFlags_SHOW_FORCED: ShowImeFlags = 2;
#[doc = " Flags to be passed to GameTextInput_showIme."]
pub type ShowImeFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Show the IME. Calls InputMethodManager.showSoftInput()."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param flags Defined in ShowImeFlags above. For more information see:"]
    #[doc = " https://developer.android.com/reference/android/view/inputmethod/InputMethodManager"]
    pub fn GameTextInput_showIme(input: *mut GameTextInput, flags: u32);
}
pub const HideImeFlags_HIDE_IME_UNDEFINED: HideImeFlags = 0;
pub const HideImeFlags_HIDE_IMPLICIT_ONLY: HideImeFlags = 1;
pub const HideImeFlags_HIDE_NOT_ALWAYS: HideImeFlags = 2;
#[doc = " Flags to be passed to GameTextInput_hideIme."]
pub type HideImeFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Show the IME. Calls InputMethodManager.hideSoftInputFromWindow()."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param flags Defined in HideImeFlags above. For more information see:"]
    #[doc = " https://developer.android.com/reference/android/view/inputmethod/InputMethodManager"]
    pub fn GameTextInput_hideIme(input: *mut GameTextInput, flags: u32);
}
extern "C" {
    #[doc = " Call a callback with the current GameTextInput state, which may have been"]
    #[doc = " modified by changes in the IME and calls to GameTextInput_setState. We use a"]
    #[doc = " callback rather than returning the state in order to simplify ownership of"]
    #[doc = " text_UTF8 strings. These strings are only valid during the calling of the"]
    #[doc = " callback."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param callback A function that will be called with valid state."]
    #[doc = " @param context Context used by the callback."]
    pub fn GameTextInput_getState(
        input: *mut GameTextInput,
        callback: GameTextInputGetStateCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set the current GameTextInput state. This state is reflected to any active"]
    #[doc = " IME."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param state The state to set. Ownership is maintained by the caller and must"]
    #[doc = " remain valid for the duration of the call."]
    pub fn GameTextInput_setState(input: *mut GameTextInput, state: *const GameTextInputState);
}
#[doc = " Type of the callback needed by GameTextInput_setEventCallback that will be"]
#[doc = " called every time the IME state changes."]
#[doc = " @param context User-defined context set in GameTextInput_setEventCallback."]
#[doc = " @param current_state Current IME state, owned by the library and valid during"]
#[doc = " the callback."]
pub type GameTextInputEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        current_state: *const GameTextInputState,
    ),
>;
extern "C" {
    #[doc = " Optionally set a callback to be called whenever the IME state changes."]
    #[doc = " Not necessary if you are using GameActivity, which handles these callbacks"]
    #[doc = " for you."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param callback Called by the library when the IME state changes."]
    #[doc = " @param context Context passed as first argument to the callback."]
    pub fn GameTextInput_setEventCallback(
        input: *mut GameTextInput,
        callback: GameTextInputEventCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Type of the callback needed by GameTextInput_setImeInsetsCallback that will"]
#[doc = " be called every time the IME window insets change."]
#[doc = " @param context User-defined context set in"]
#[doc = " GameTextInput_setImeWIndowInsetsCallback."]
#[doc = " @param current_insets Current IME insets, owned by the library and valid"]
#[doc = " during the callback."]
pub type GameTextInputImeInsetsCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, current_insets: *const ARect),
>;
extern "C" {
    #[doc = " Optionally set a callback to be called whenever the IME insets change."]
    #[doc = " Not necessary if you are using GameActivity, which handles these callbacks"]
    #[doc = " for you."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param callback Called by the library when the IME insets change."]
    #[doc = " @param context Context passed as first argument to the callback."]
    pub fn GameTextInput_setImeInsetsCallback(
        input: *mut GameTextInput,
        callback: GameTextInputImeInsetsCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the current window insets for the IME."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param insets Filled with the current insets by this function."]
    pub fn GameTextInput_getImeInsets(input: *const GameTextInput, insets: *mut ARect);
}
extern "C" {
    #[doc = " Unless using GameActivity, it is required to call this function from your"]
    #[doc = " Java gametextinput.Listener.onImeInsetsChanged method to"]
    #[doc = " trigger any event callbacks. When using GameActivity, this does not need to"]
    #[doc = " be called as insets processing is handled by the Activity."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param eventState A Java gametextinput.State object."]
    pub fn GameTextInput_processImeInsets(input: *mut GameTextInput, insets: *const ARect);
}
extern "C" {
    #[doc = " Convert a GameTextInputState struct to a Java gametextinput.State object."]
    #[doc = " Don't forget to delete the returned Java local ref when you're done."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param state Input state to convert."]
    #[doc = " @return A Java object of class gametextinput.State. The caller is required to"]
    #[doc = " delete this local reference."]
    pub fn GameTextInputState_toJava(
        input: *const GameTextInput,
        state: *const GameTextInputState,
    ) -> jobject;
}
extern "C" {
    #[doc = " Convert from a Java gametextinput.State object into a C GameTextInputState"]
    #[doc = " struct."]
    #[doc = " @param input A valid GameTextInput library handle."]
    #[doc = " @param state A Java gametextinput.State object."]
    #[doc = " @param callback A function called with the C struct, valid for the duration"]
    #[doc = " of the call."]
    #[doc = " @param context Context passed to the callback."]
    pub fn GameTextInputState_fromJava(
        input: *const GameTextInput,
        state: jobject,
        callback: GameTextInputGetStateCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure defines the native side of an android.app.GameActivity."]
#[doc = " It is created by the framework, and handed to the application's native"]
#[doc = " code as it is being launched."]
#[repr(C)]
pub struct GameActivity {
    #[doc = " Pointer to the callback function table of the native application."]
    #[doc = " You can set the functions here to your own callbacks.  The callbacks"]
    #[doc = " pointer itself here should not be changed; it is allocated and managed"]
    #[doc = " for you by the framework."]
    pub callbacks: *mut GameActivityCallbacks,
    #[doc = " The global handle on the process's Java VM."]
    pub vm: *mut JavaVM,
    #[doc = " JNI context for the main thread of the app.  Note that this field"]
    #[doc = " can ONLY be used from the main thread of the process; that is, the"]
    #[doc = " thread that calls into the GameActivityCallbacks."]
    pub env: *mut JNIEnv,
    #[doc = " The GameActivity object handle."]
    pub javaGameActivity: jobject,
    #[doc = " Path to this application's internal data directory."]
    pub internalDataPath: *const ::std::os::raw::c_char,
    #[doc = " Path to this application's external (removable/mountable) data directory."]
    pub externalDataPath: *const ::std::os::raw::c_char,
    #[doc = " The platform's SDK version code."]
    pub sdkVersion: i32,
    #[doc = " This is the native instance of the application.  It is not used by"]
    #[doc = " the framework, but can be set by the application to its own instance"]
    #[doc = " state."]
    pub instance: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to the Asset Manager instance for the application.  The"]
    #[doc = " application uses this to access binary assets bundled inside its own .apk"]
    #[doc = " file."]
    pub assetManager: *mut AAssetManager,
    #[doc = " Available starting with Honeycomb: path to the directory containing"]
    #[doc = " the application's OBB files (if any).  If the app doesn't have any"]
    #[doc = " OBB files, this directory may not exist."]
    pub obbPath: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GameActivity() {
    assert_eq!(
        ::std::mem::size_of::<GameActivity>(),
        40usize,
        concat!("Size of: ", stringify!(GameActivity))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivity>(),
        4usize,
        concat!("Alignment of ", stringify!(GameActivity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).callbacks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).vm as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).env as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).javaGameActivity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(javaGameActivity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).internalDataPath as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(internalDataPath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).externalDataPath as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(externalDataPath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).sdkVersion as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(sdkVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).instance as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).assetManager as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(assetManager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivity>())).obbPath as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivity),
            "::",
            stringify!(obbPath)
        )
    );
}
#[doc = " \\brief Describe information about a pointer, found in a"]
#[doc = " GameActivityMotionEvent."]
#[doc = ""]
#[doc = " You can read values directly from this structure, or use helper functions"]
#[doc = " (`GameActivityPointerAxes_getX`, `GameActivityPointerAxes_getY` and"]
#[doc = " `GameActivityPointerAxes_getAxisValue`)."]
#[doc = ""]
#[doc = " The X axis and Y axis are enabled by default but any other axis that you want"]
#[doc = " to read **must** be enabled first, using"]
#[doc = " `GameActivityPointerAxes_enableAxis`."]
#[doc = ""]
#[doc = " \\see GameActivityMotionEvent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameActivityPointerAxes {
    pub id: i32,
    pub toolType: i32,
    pub axisValues: [f32; 48usize],
    pub rawX: f32,
    pub rawY: f32,
}
#[test]
fn bindgen_test_layout_GameActivityPointerAxes() {
    assert_eq!(
        ::std::mem::size_of::<GameActivityPointerAxes>(),
        208usize,
        concat!("Size of: ", stringify!(GameActivityPointerAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivityPointerAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(GameActivityPointerAxes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityPointerAxes>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityPointerAxes),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityPointerAxes>())).toolType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityPointerAxes),
            "::",
            stringify!(toolType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityPointerAxes>())).axisValues as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityPointerAxes),
            "::",
            stringify!(axisValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityPointerAxes>())).rawX as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityPointerAxes),
            "::",
            stringify!(rawX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityPointerAxes>())).rawY as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityPointerAxes),
            "::",
            stringify!(rawY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameActivityHistoricalPointerAxes {
    pub eventTime: i64,
    pub axisValues: [f32; 48usize],
}
#[test]
fn bindgen_test_layout_GameActivityHistoricalPointerAxes() {
    assert_eq!(
        ::std::mem::size_of::<GameActivityHistoricalPointerAxes>(),
        200usize,
        concat!("Size of: ", stringify!(GameActivityHistoricalPointerAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivityHistoricalPointerAxes>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GameActivityHistoricalPointerAxes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityHistoricalPointerAxes>())).eventTime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityHistoricalPointerAxes),
            "::",
            stringify!(eventTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityHistoricalPointerAxes>())).axisValues as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityHistoricalPointerAxes),
            "::",
            stringify!(axisValues)
        )
    );
}
extern "C" {
    #[doc = " \\brief Enable the specified axis, so that its value is reported in the"]
    #[doc = " GameActivityPointerAxes structures stored in a motion event."]
    #[doc = ""]
    #[doc = " You must enable any axis that you want to read, apart from"]
    #[doc = " `AMOTION_EVENT_AXIS_X` and `AMOTION_EVENT_AXIS_Y` that are enabled by"]
    #[doc = " default."]
    #[doc = ""]
    #[doc = " If the axis index is out of range, nothing is done."]
    pub fn GameActivityPointerAxes_enableAxis(axis: i32);
}
extern "C" {
    #[doc = " \\brief Disable the specified axis. Its value won't be reported in the"]
    #[doc = " GameActivityPointerAxes structures stored in a motion event anymore."]
    #[doc = ""]
    #[doc = " Apart from X and Y, any axis that you want to read **must** be enabled first,"]
    #[doc = " using `GameActivityPointerAxes_enableAxis`."]
    #[doc = ""]
    #[doc = " If the axis index is out of range, nothing is done."]
    pub fn GameActivityPointerAxes_disableAxis(axis: i32);
}
extern "C" {
    #[doc = " \\brief Enable the specified axis, so that its value is reported in the"]
    #[doc = " GameActivityHistoricalPointerAxes structures associated with a motion event."]
    #[doc = ""]
    #[doc = " You must enable any axis that you want to read (no axes are enabled by"]
    #[doc = " default)."]
    #[doc = ""]
    #[doc = " If the axis index is out of range, nothing is done."]
    pub fn GameActivityHistoricalPointerAxes_enableAxis(axis: i32);
}
extern "C" {
    #[doc = " \\brief Disable the specified axis. Its value won't be reported in the"]
    #[doc = " GameActivityHistoricalPointerAxes structures associated with motion events"]
    #[doc = " anymore."]
    #[doc = ""]
    #[doc = " If the axis index is out of range, nothing is done."]
    pub fn GameActivityHistoricalPointerAxes_disableAxis(axis: i32);
}
#[doc = " \\brief Describe a motion event that happened on the GameActivity SurfaceView."]
#[doc = ""]
#[doc = " This is 1:1 mapping to the information contained in a Java `MotionEvent`"]
#[doc = " (see https://developer.android.com/reference/android/view/MotionEvent)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameActivityMotionEvent {
    pub deviceId: i32,
    pub source: i32,
    pub action: i32,
    pub eventTime: i64,
    pub downTime: i64,
    pub flags: i32,
    pub metaState: i32,
    pub actionButton: i32,
    pub buttonState: i32,
    pub classification: i32,
    pub edgeFlags: i32,
    pub pointerCount: u32,
    pub pointers: [GameActivityPointerAxes; 8usize],
    pub precisionX: f32,
    pub precisionY: f32,
    pub historicalStart: i16,
    pub historicalCount: i16,
}
#[test]
fn bindgen_test_layout_GameActivityMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<GameActivityMotionEvent>(),
        1732usize,
        concat!("Size of: ", stringify!(GameActivityMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivityMotionEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(GameActivityMotionEvent))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).deviceId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityMotionEvent>())).source as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityMotionEvent>())).action as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).eventTime as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(eventTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).downTime as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(downTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityMotionEvent>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).metaState as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(metaState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).actionButton as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(actionButton)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).buttonState as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(buttonState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).classification as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(classification)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).edgeFlags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(edgeFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).pointerCount as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(pointerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).pointers as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(pointers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).precisionX as *const _ as usize
        },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(precisionX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).precisionY as *const _ as usize
        },
        1724usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(precisionY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).historicalStart as *const _ as usize
        },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(historicalStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityMotionEvent>())).historicalCount as *const _ as usize
        },
        1730usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityMotionEvent),
            "::",
            stringify!(historicalCount)
        )
    );
}
#[doc = " \\brief Describe a key event that happened on the GameActivity SurfaceView."]
#[doc = ""]
#[doc = " This is 1:1 mapping to the information contained in a Java `KeyEvent`"]
#[doc = " (see https://developer.android.com/reference/android/view/KeyEvent)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameActivityKeyEvent {
    pub deviceId: i32,
    pub source: i32,
    pub action: i32,
    pub eventTime: i64,
    pub downTime: i64,
    pub flags: i32,
    pub metaState: i32,
    pub modifiers: i32,
    pub repeatCount: i32,
    pub keyCode: i32,
    pub scanCode: i32,
}
#[test]
fn bindgen_test_layout_GameActivityKeyEvent() {
    assert_eq!(
        ::std::mem::size_of::<GameActivityKeyEvent>(),
        52usize,
        concat!("Size of: ", stringify!(GameActivityKeyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivityKeyEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(GameActivityKeyEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).deviceId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).source as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).action as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).eventTime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(eventTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).downTime as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(downTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).metaState as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(metaState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).modifiers as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityKeyEvent>())).repeatCount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(repeatCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).keyCode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(keyCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityKeyEvent>())).scanCode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityKeyEvent),
            "::",
            stringify!(scanCode)
        )
    );
}
#[doc = " A function the user should call from their callback with the data, its length"]
#[doc = " and the library- supplied context."]
pub type SaveInstanceStateRecallback = ::std::option::Option<
    unsafe extern "C" fn(
        bytes: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " {@link GameActivityCallbacks}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameActivityCallbacks {
    #[doc = " GameActivity has started.  See Java documentation for Activity.onStart()"]
    #[doc = " for more information."]
    pub onStart: ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " GameActivity has resumed.  See Java documentation for Activity.onResume()"]
    #[doc = " for more information."]
    pub onResume: ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " The framework is asking GameActivity to save its current instance state."]
    #[doc = " See the Java documentation for Activity.onSaveInstanceState() for more"]
    #[doc = " information. The user should call the recallback with their data, its"]
    #[doc = " length and the provided context; they retain ownership of the data. Note"]
    #[doc = " that the saved state will be persisted, so it can not contain any active"]
    #[doc = " entities (pointers to memory, file descriptors, etc)."]
    pub onSaveInstanceState: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut GameActivity,
            recallback: SaveInstanceStateRecallback,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " GameActivity has paused.  See Java documentation for Activity.onPause()"]
    #[doc = " for more information."]
    pub onPause: ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " GameActivity has stopped.  See Java documentation for Activity.onStop()"]
    #[doc = " for more information."]
    pub onStop: ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " GameActivity is being destroyed.  See Java documentation for"]
    #[doc = " Activity.onDestroy() for more information."]
    pub onDestroy: ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " Focus has changed in this GameActivity's window.  This is often used,"]
    #[doc = " for example, to pause a game when it loses input focus."]
    pub onWindowFocusChanged:
        ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity, hasFocus: bool)>,
    #[doc = " The drawing window for this native activity has been created.  You"]
    #[doc = " can use the given native window object to start drawing."]
    pub onNativeWindowCreated: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut GameActivity, window: *mut ANativeWindow),
    >,
    #[doc = " The drawing window for this native activity has been resized.  You should"]
    #[doc = " retrieve the new size from the window and ensure that your rendering in"]
    #[doc = " it now matches."]
    pub onNativeWindowResized: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut GameActivity,
            window: *mut ANativeWindow,
            newWidth: i32,
            newHeight: i32,
        ),
    >,
    #[doc = " The drawing window for this native activity needs to be redrawn.  To"]
    #[doc = " avoid transient artifacts during screen changes (such resizing after"]
    #[doc = " rotation), applications should not return from this function until they"]
    #[doc = " have finished drawing their window in its current state."]
    pub onNativeWindowRedrawNeeded: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut GameActivity, window: *mut ANativeWindow),
    >,
    #[doc = " The drawing window for this native activity is going to be destroyed."]
    #[doc = " You MUST ensure that you do not touch the window object after returning"]
    #[doc = " from this function: in the common case of drawing to the window from"]
    #[doc = " another thread, that means the implementation of this callback must"]
    #[doc = " properly synchronize with the other thread to stop its drawing before"]
    #[doc = " returning from here."]
    pub onNativeWindowDestroyed: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut GameActivity, window: *mut ANativeWindow),
    >,
    #[doc = " The current device AConfiguration has changed.  The new configuration can"]
    #[doc = " be retrieved from assetManager."]
    pub onConfigurationChanged:
        ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
    #[doc = " The system is running low on memory.  Use this callback to release"]
    #[doc = " resources you do not need, to help the system avoid killing more"]
    #[doc = " important processes."]
    pub onTrimMemory: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut GameActivity, level: ::std::os::raw::c_int),
    >,
    #[doc = " Callback called for every MotionEvent done on the GameActivity"]
    #[doc = " SurfaceView. Ownership of `event` is maintained by the library and it is"]
    #[doc = " only valid during the callback."]
    pub onTouchEvent: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut GameActivity,
            event: *const GameActivityMotionEvent,
            historical: *const GameActivityHistoricalPointerAxes,
            historicalLen: ::std::os::raw::c_int,
        ) -> bool,
    >,
    #[doc = " Callback called for every key down event on the GameActivity SurfaceView."]
    #[doc = " Ownership of `event` is maintained by the library and it is only valid"]
    #[doc = " during the callback."]
    pub onKeyDown: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut GameActivity,
            event: *const GameActivityKeyEvent,
        ) -> bool,
    >,
    #[doc = " Callback called for every key up event on the GameActivity SurfaceView."]
    #[doc = " Ownership of `event` is maintained by the library and it is only valid"]
    #[doc = " during the callback."]
    pub onKeyUp: ::std::option::Option<
        unsafe extern "C" fn(
            activity: *mut GameActivity,
            event: *const GameActivityKeyEvent,
        ) -> bool,
    >,
    #[doc = " Callback called for every soft-keyboard text input event."]
    #[doc = " Ownership of `state` is maintained by the library and it is only valid"]
    #[doc = " during the callback."]
    pub onTextInputEvent: ::std::option::Option<
        unsafe extern "C" fn(activity: *mut GameActivity, state: *const GameTextInputState),
    >,
    #[doc = " Callback called when WindowInsets of the main app window have changed."]
    #[doc = " Call GameActivity_getWindowInsets to retrieve the insets themselves."]
    pub onWindowInsetsChanged:
        ::std::option::Option<unsafe extern "C" fn(activity: *mut GameActivity)>,
}
#[test]
fn bindgen_test_layout_GameActivityCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<GameActivityCallbacks>(),
        72usize,
        concat!("Size of: ", stringify!(GameActivityCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<GameActivityCallbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(GameActivityCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onResume as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onResume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onSaveInstanceState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onSaveInstanceState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onPause as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onPause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onStop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onDestroy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onDestroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onWindowFocusChanged as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onWindowFocusChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onNativeWindowCreated as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onNativeWindowCreated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onNativeWindowResized as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onNativeWindowResized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onNativeWindowRedrawNeeded as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onNativeWindowRedrawNeeded)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onNativeWindowDestroyed as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onNativeWindowDestroyed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onConfigurationChanged as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onConfigurationChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onTrimMemory as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onTrimMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onTouchEvent as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onTouchEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onKeyDown as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onKeyDown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GameActivityCallbacks>())).onKeyUp as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onKeyUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onTextInputEvent as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onTextInputEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GameActivityCallbacks>())).onWindowInsetsChanged as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GameActivityCallbacks),
            "::",
            stringify!(onWindowInsetsChanged)
        )
    );
}
extern "C" {
    #[doc = " \\brief Convert a Java `MotionEvent` to a `GameActivityMotionEvent`."]
    #[doc = ""]
    #[doc = " This is done automatically by the GameActivity: see `onTouchEvent` to set"]
    #[doc = " a callback to consume the received events."]
    #[doc = " This function can be used if you re-implement events handling in your own"]
    #[doc = " activity. On return, the out_event->historicalStart will be zero, and should"]
    #[doc = " be updated to index into whatever buffer out_historical is copied."]
    #[doc = " On return the length of out_historical is"]
    #[doc = " (out_event->pointerCount x out_event->historicalCount) and is in a"]
    #[doc = " pointer-major order (i.e. all axis for a pointer are contiguous)"]
    #[doc = " Ownership of out_event is maintained by the caller."]
    pub fn GameActivityMotionEvent_fromJava(
        env: *mut JNIEnv,
        motionEvent: jobject,
        out_event: *mut GameActivityMotionEvent,
        out_historical: *mut GameActivityHistoricalPointerAxes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Convert a Java `KeyEvent` to a `GameActivityKeyEvent`."]
    #[doc = ""]
    #[doc = " This is done automatically by the GameActivity: see `onKeyUp` and `onKeyDown`"]
    #[doc = " to set a callback to consume the received events."]
    #[doc = " This function can be used if you re-implement events handling in your own"]
    #[doc = " activity."]
    #[doc = " Ownership of out_event is maintained by the caller."]
    pub fn GameActivityKeyEvent_fromJava(
        env: *mut JNIEnv,
        motionEvent: jobject,
        out_event: *mut GameActivityKeyEvent,
    );
}
#[doc = " This is the function that must be in the native code to instantiate the"]
#[doc = " application's native activity.  It is called with the activity instance (see"]
#[doc = " above); if the code is being instantiated from a previously saved instance,"]
#[doc = " the savedState will be non-NULL and point to the saved data.  You must make"]
#[doc = " any copy of this data you need -- it will be released after you return from"]
#[doc = " this function."]
pub type GameActivity_createFunc = ::std::option::Option<
    unsafe extern "C" fn(
        activity: *mut GameActivity,
        savedState: *mut ::std::os::raw::c_void,
        savedStateSize: size_t,
    ),
>;
extern "C" {
    #[doc = " Finish the given activity.  Its finish() method will be called, causing it"]
    #[doc = " to be stopped and destroyed.  Note that this method can be called from"]
    #[doc = " *any* thread; it will send a message to the main thread of the process"]
    #[doc = " where the Java finish call will take place."]
    pub fn GameActivity_finish(activity: *mut GameActivity);
}
#[doc = " As long as this window is visible to the user, allow the lock"]
#[doc = " screen to activate while the screen is on.  This can be used"]
#[doc = " independently, or in combination with {@link"]
#[doc = " GAMEACTIVITY_FLAG_KEEP_SCREEN_ON} and/or {@link"]
#[doc = " GAMEACTIVITY_FLAG_SHOW_WHEN_LOCKED}"]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_ALLOW_LOCK_WHILE_SCREEN_ON:
    GameActivitySetWindowFlags = 1;
#[doc = " Everything behind this window will be dimmed."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_DIM_BEHIND: GameActivitySetWindowFlags = 2;
#[doc = " Blur everything behind this window."]
#[doc = " @deprecated Blurring is no longer supported."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_BLUR_BEHIND: GameActivitySetWindowFlags = 4;
#[doc = " This window won't ever get key input focus, so the"]
#[doc = " user can not send key or other button events to it.  Those will"]
#[doc = " instead go to whatever focusable window is behind it.  This flag"]
#[doc = " will also enable {@link GAMEACTIVITY_FLAG_NOT_TOUCH_MODAL} whether or not"]
#[doc = " that is explicitly set."]
#[doc = ""]
#[doc = " Setting this flag also implies that the window will not need to"]
#[doc = " interact with"]
#[doc = " a soft input method, so it will be Z-ordered and positioned"]
#[doc = " independently of any active input method (typically this means it"]
#[doc = " gets Z-ordered on top of the input method, so it can use the full"]
#[doc = " screen for its content and cover the input method if needed.  You"]
#[doc = " can use {@link GAMEACTIVITY_FLAG_ALT_FOCUSABLE_IM} to modify this"]
#[doc = " behavior."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_NOT_FOCUSABLE: GameActivitySetWindowFlags =
    8;
#[doc = " This window can never receive touch events."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_NOT_TOUCHABLE: GameActivitySetWindowFlags =
    16;
#[doc = " Even when this window is focusable (its"]
#[doc = " {@link GAMEACTIVITY_FLAG_NOT_FOCUSABLE} is not set), allow any pointer"]
#[doc = " events outside of the window to be sent to the windows behind it."]
#[doc = " Otherwise it will consume all pointer events itself, regardless of"]
#[doc = " whether they are inside of the window."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_NOT_TOUCH_MODAL: GameActivitySetWindowFlags =
    32;
#[doc = " When set, if the device is asleep when the touch"]
#[doc = " screen is pressed, you will receive this first touch event.  Usually"]
#[doc = " the first touch event is consumed by the system since the user can"]
#[doc = " not see what they are pressing on."]
#[doc = ""]
#[doc = " @deprecated This flag has no effect."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_TOUCHABLE_WHEN_WAKING:
    GameActivitySetWindowFlags = 64;
#[doc = " As long as this window is visible to the user, keep"]
#[doc = " the device's screen turned on and bright."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_KEEP_SCREEN_ON: GameActivitySetWindowFlags =
    128;
#[doc = " Place the window within the entire screen, ignoring"]
#[doc = " decorations around the border (such as the status bar).  The"]
#[doc = " window must correctly position its contents to take the screen"]
#[doc = " decoration into account."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_LAYOUT_IN_SCREEN:
    GameActivitySetWindowFlags = 256;
#[doc = " Allows the window to extend outside of the screen."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_LAYOUT_NO_LIMITS:
    GameActivitySetWindowFlags = 512;
#[doc = " Hide all screen decorations (such as the status"]
#[doc = " bar) while this window is displayed.  This allows the window to"]
#[doc = " use the entire display space for itself -- the status bar will"]
#[doc = " be hidden when an app window with this flag set is on the top"]
#[doc = " layer. A fullscreen window will ignore a value of {@link"]
#[doc = " GAMEACTIVITY_SOFT_INPUT_ADJUST_RESIZE}; the window will stay"]
#[doc = " fullscreen and will not resize."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_FULLSCREEN: GameActivitySetWindowFlags =
    1024;
#[doc = " Override {@link GAMEACTIVITY_FLAG_FULLSCREEN} and force the"]
#[doc = " screen decorations (such as the status bar) to be shown."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_FORCE_NOT_FULLSCREEN:
    GameActivitySetWindowFlags = 2048;
#[doc = " Turn on dithering when compositing this window to"]
#[doc = " the screen."]
#[doc = " @deprecated This flag is no longer used."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_DITHER: GameActivitySetWindowFlags = 4096;
#[doc = " Treat the content of the window as secure, preventing"]
#[doc = " it from appearing in screenshots or from being viewed on non-secure"]
#[doc = " displays."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_SECURE: GameActivitySetWindowFlags = 8192;
#[doc = " A special mode where the layout parameters are used"]
#[doc = " to perform scaling of the surface when it is composited to the"]
#[doc = " screen."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_SCALED: GameActivitySetWindowFlags = 16384;
#[doc = " Intended for windows that will often be used when the user is"]
#[doc = " holding the screen against their face, it will aggressively"]
#[doc = " filter the event stream to prevent unintended presses in this"]
#[doc = " situation that may not be desired for a particular window, when"]
#[doc = " such an event stream is detected, the application will receive"]
#[doc = " a {@link AMOTION_EVENT_ACTION_CANCEL} to indicate this so"]
#[doc = " applications can handle this accordingly by taking no action on"]
#[doc = " the event until the finger is released."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_IGNORE_CHEEK_PRESSES:
    GameActivitySetWindowFlags = 32768;
#[doc = " A special option only for use in combination with"]
#[doc = " {@link GAMEACTIVITY_FLAG_LAYOUT_IN_SCREEN}.  When requesting layout in"]
#[doc = " the screen your window may appear on top of or behind screen decorations"]
#[doc = " such as the status bar.  By also including this flag, the window"]
#[doc = " manager will report the inset rectangle needed to ensure your"]
#[doc = " content is not covered by screen decorations."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_LAYOUT_INSET_DECOR:
    GameActivitySetWindowFlags = 65536;
#[doc = " Invert the state of {@link GAMEACTIVITY_FLAG_NOT_FOCUSABLE} with"]
#[doc = " respect to how this window interacts with the current method."]
#[doc = " That is, if FLAG_NOT_FOCUSABLE is set and this flag is set,"]
#[doc = " then the window will behave as if it needs to interact with the"]
#[doc = " input method and thus be placed behind/away from it; if {@link"]
#[doc = " GAMEACTIVITY_FLAG_NOT_FOCUSABLE} is not set and this flag is set,"]
#[doc = " then the window will behave as if it doesn't need to interact"]
#[doc = " with the input method and can be placed to use more space and"]
#[doc = " cover the input method."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_ALT_FOCUSABLE_IM:
    GameActivitySetWindowFlags = 131072;
#[doc = " If you have set {@link GAMEACTIVITY_FLAG_NOT_TOUCH_MODAL}, you"]
#[doc = " can set this flag to receive a single special MotionEvent with"]
#[doc = " the action"]
#[doc = " {@link AMOTION_EVENT_ACTION_OUTSIDE} for"]
#[doc = " touches that occur outside of your window.  Note that you will not"]
#[doc = " receive the full down/move/up gesture, only the location of the"]
#[doc = " first down as an {@link AMOTION_EVENT_ACTION_OUTSIDE}."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_WATCH_OUTSIDE_TOUCH:
    GameActivitySetWindowFlags = 262144;
#[doc = " Special flag to let windows be shown when the screen"]
#[doc = " is locked. This will let application windows take precedence over"]
#[doc = " key guard or any other lock screens. Can be used with"]
#[doc = " {@link GAMEACTIVITY_FLAG_KEEP_SCREEN_ON} to turn screen on and display"]
#[doc = " windows directly before showing the key guard window.  Can be used with"]
#[doc = " {@link GAMEACTIVITY_FLAG_DISMISS_KEYGUARD} to automatically fully"]
#[doc = " dismisss non-secure keyguards.  This flag only applies to the top-most"]
#[doc = " full-screen window."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_SHOW_WHEN_LOCKED:
    GameActivitySetWindowFlags = 524288;
#[doc = " Ask that the system wallpaper be shown behind"]
#[doc = " your window.  The window surface must be translucent to be able"]
#[doc = " to actually see the wallpaper behind it; this flag just ensures"]
#[doc = " that the wallpaper surface will be there if this window actually"]
#[doc = " has translucent regions."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_SHOW_WALLPAPER: GameActivitySetWindowFlags =
    1048576;
#[doc = " When set as a window is being added or made"]
#[doc = " visible, once the window has been shown then the system will"]
#[doc = " poke the power manager's user activity (as if the user had woken"]
#[doc = " up the device) to turn the screen on."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_TURN_SCREEN_ON: GameActivitySetWindowFlags =
    2097152;
#[doc = " When set the window will cause the keyguard to"]
#[doc = " be dismissed, only if it is not a secure lock keyguard.  Because such"]
#[doc = " a keyguard is not needed for security, it will never re-appear if"]
#[doc = " the user navigates to another window (in contrast to"]
#[doc = " {@link GAMEACTIVITY_FLAG_SHOW_WHEN_LOCKED}, which will only temporarily"]
#[doc = " hide both secure and non-secure keyguards but ensure they reappear"]
#[doc = " when the user moves to another UI that doesn't hide them)."]
#[doc = " If the keyguard is currently active and is secure (requires an"]
#[doc = " unlock pattern) than the user will still need to confirm it before"]
#[doc = " seeing this window, unless {@link GAMEACTIVITY_FLAG_SHOW_WHEN_LOCKED} has"]
#[doc = " also been set."]
pub const GameActivitySetWindowFlags_GAMEACTIVITY_FLAG_DISMISS_KEYGUARD:
    GameActivitySetWindowFlags = 4194304;
#[doc = " Flags for GameActivity_setWindowFlags,"]
#[doc = " as per the Java API at android.view.WindowManager.LayoutParams."]
pub type GameActivitySetWindowFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Change the window flags of the given activity.  Calls getWindow().setFlags()"]
    #[doc = " of the given activity."]
    #[doc = " Note that some flags must be set before the window decoration is created,"]
    #[doc = " see"]
    #[doc = " https://developer.android.com/reference/android/view/Window#setFlags(int,%20int)."]
    #[doc = " Note also that this method can be called from"]
    #[doc = " *any* thread; it will send a message to the main thread of the process"]
    #[doc = " where the Java finish call will take place."]
    pub fn GameActivity_setWindowFlags(
        activity: *mut GameActivity,
        addFlags: u32,
        removeFlags: u32,
    );
}
#[doc = " Implicit request to show the input window, not as the result"]
#[doc = " of a direct request by the user."]
pub const GameActivityShowSoftInputFlags_GAMEACTIVITY_SHOW_SOFT_INPUT_IMPLICIT:
    GameActivityShowSoftInputFlags = 1;
#[doc = " The user has forced the input method open (such as by"]
#[doc = " long-pressing menu) so it should not be closed until they"]
#[doc = " explicitly do so."]
pub const GameActivityShowSoftInputFlags_GAMEACTIVITY_SHOW_SOFT_INPUT_FORCED:
    GameActivityShowSoftInputFlags = 2;
#[doc = " Flags for GameActivity_showSoftInput; see the Java InputMethodManager"]
#[doc = " API for documentation."]
pub type GameActivityShowSoftInputFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Show the IME while in the given activity.  Calls"]
    #[doc = " InputMethodManager.showSoftInput() for the given activity.  Note that this"]
    #[doc = " method can be called from *any* thread; it will send a message to the main"]
    #[doc = " thread of the process where the Java call will take place."]
    pub fn GameActivity_showSoftInput(activity: *mut GameActivity, flags: u32);
}
extern "C" {
    #[doc = " Set the text entry state (see documentation of the GameTextInputState struct"]
    #[doc = " in the Game Text Input library reference)."]
    #[doc = ""]
    #[doc = " Ownership of the state is maintained by the caller."]
    pub fn GameActivity_setTextInputState(
        activity: *mut GameActivity,
        state: *const GameTextInputState,
    );
}
extern "C" {
    #[doc = " Get the last-received text entry state (see documentation of the"]
    #[doc = " GameTextInputState struct in the Game Text Input library reference)."]
    #[doc = ""]
    pub fn GameActivity_getTextInputState(
        activity: *mut GameActivity,
        callback: GameTextInputGetStateCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get a pointer to the GameTextInput library instance."]
    pub fn GameActivity_getTextInput(activity: *const GameActivity) -> *mut GameTextInput;
}
#[doc = " The soft input window should only be hidden if it was not"]
#[doc = " explicitly shown by the user."]
pub const GameActivityHideSoftInputFlags_GAMEACTIVITY_HIDE_SOFT_INPUT_IMPLICIT_ONLY:
    GameActivityHideSoftInputFlags = 1;
#[doc = " The soft input window should normally be hidden, unless it was"]
#[doc = " originally shown with {@link GAMEACTIVITY_SHOW_SOFT_INPUT_FORCED}."]
pub const GameActivityHideSoftInputFlags_GAMEACTIVITY_HIDE_SOFT_INPUT_NOT_ALWAYS:
    GameActivityHideSoftInputFlags = 2;
#[doc = " Flags for GameActivity_hideSoftInput; see the Java InputMethodManager"]
#[doc = " API for documentation."]
pub type GameActivityHideSoftInputFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Hide the IME while in the given activity.  Calls"]
    #[doc = " InputMethodManager.hideSoftInput() for the given activity.  Note that this"]
    #[doc = " method can be called from *any* thread; it will send a message to the main"]
    #[doc = " thread of the process where the Java finish call will take place."]
    pub fn GameActivity_hideSoftInput(activity: *mut GameActivity, flags: u32);
}
extern "C" {
    #[doc = " Get the current window insets of the particular component. See"]
    #[doc = " https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.Type"]
    #[doc = " for more details."]
    #[doc = " You can use these insets to influence what you show on the screen."]
    pub fn GameActivity_getWindowInsets(
        activity: *mut GameActivity,
        type_: GameCommonInsetsType,
        insets: *mut ARect,
    );
}
extern "C" {
    #[doc = " Set options on how the IME behaves when it is requested for text input."]
    #[doc = " See"]
    #[doc = " https://developer.android.com/reference/android/view/inputmethod/EditorInfo"]
    #[doc = " for the meaning of inputType, actionId and imeOptions."]
    #[doc = ""]
    #[doc = " Note that this function will attach the current thread to the JVM if it is"]
    #[doc = " not already attached, so the caller must detach the thread from the JVM"]
    #[doc = " before the thread is destroyed using DetachCurrentThread."]
    pub fn GameActivity_setImeEditorInfo(
        activity: *mut GameActivity,
        inputType: ::std::os::raw::c_int,
        actionId: ::std::os::raw::c_int,
        imeOptions: ::std::os::raw::c_int,
    );
}
pub const ACONFIGURATION_ORIENTATION_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_ORIENTATION_PORT: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_ORIENTATION_LAND: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_ORIENTATION_SQUARE: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_TOUCHSCREEN_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_TOUCHSCREEN_NOTOUCH: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_TOUCHSCREEN_STYLUS: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_TOUCHSCREEN_FINGER: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_DENSITY_DEFAULT: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_DENSITY_LOW: ::std::os::raw::c_uint = 120;
pub const ACONFIGURATION_DENSITY_MEDIUM: ::std::os::raw::c_uint = 160;
pub const ACONFIGURATION_DENSITY_TV: ::std::os::raw::c_uint = 213;
pub const ACONFIGURATION_DENSITY_HIGH: ::std::os::raw::c_uint = 240;
pub const ACONFIGURATION_DENSITY_XHIGH: ::std::os::raw::c_uint = 320;
pub const ACONFIGURATION_DENSITY_XXHIGH: ::std::os::raw::c_uint = 480;
pub const ACONFIGURATION_DENSITY_XXXHIGH: ::std::os::raw::c_uint = 640;
pub const ACONFIGURATION_DENSITY_ANY: ::std::os::raw::c_uint = 65534;
pub const ACONFIGURATION_DENSITY_NONE: ::std::os::raw::c_uint = 65535;
pub const ACONFIGURATION_KEYBOARD_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_KEYBOARD_NOKEYS: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_KEYBOARD_QWERTY: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_KEYBOARD_12KEY: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_NAVIGATION_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_NAVIGATION_NONAV: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_NAVIGATION_DPAD: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_NAVIGATION_TRACKBALL: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_NAVIGATION_WHEEL: ::std::os::raw::c_uint = 4;
pub const ACONFIGURATION_KEYSHIDDEN_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_KEYSHIDDEN_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_KEYSHIDDEN_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_KEYSHIDDEN_SOFT: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_NAVHIDDEN_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_NAVHIDDEN_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_NAVHIDDEN_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_SCREENSIZE_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_SCREENSIZE_SMALL: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_SCREENSIZE_NORMAL: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_SCREENSIZE_LARGE: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_SCREENSIZE_XLARGE: ::std::os::raw::c_uint = 4;
pub const ACONFIGURATION_SCREENLONG_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_SCREENLONG_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_SCREENLONG_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_SCREENROUND_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_SCREENROUND_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_SCREENROUND_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_WIDE_COLOR_GAMUT_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_HDR_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_HDR_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_HDR_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_UI_MODE_TYPE_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_UI_MODE_TYPE_NORMAL: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_UI_MODE_TYPE_DESK: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_UI_MODE_TYPE_CAR: ::std::os::raw::c_uint = 3;
pub const ACONFIGURATION_UI_MODE_TYPE_TELEVISION: ::std::os::raw::c_uint = 4;
pub const ACONFIGURATION_UI_MODE_TYPE_APPLIANCE: ::std::os::raw::c_uint = 5;
pub const ACONFIGURATION_UI_MODE_TYPE_WATCH: ::std::os::raw::c_uint = 6;
pub const ACONFIGURATION_UI_MODE_TYPE_VR_HEADSET: ::std::os::raw::c_uint = 7;
pub const ACONFIGURATION_UI_MODE_NIGHT_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_UI_MODE_NIGHT_NO: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_UI_MODE_NIGHT_YES: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_SCREEN_WIDTH_DP_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_SCREEN_HEIGHT_DP_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_SMALLEST_SCREEN_WIDTH_DP_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_LAYOUTDIR_ANY: ::std::os::raw::c_uint = 0;
pub const ACONFIGURATION_LAYOUTDIR_LTR: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_LAYOUTDIR_RTL: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_MCC: ::std::os::raw::c_uint = 1;
pub const ACONFIGURATION_MNC: ::std::os::raw::c_uint = 2;
pub const ACONFIGURATION_LOCALE: ::std::os::raw::c_uint = 4;
pub const ACONFIGURATION_TOUCHSCREEN: ::std::os::raw::c_uint = 8;
pub const ACONFIGURATION_KEYBOARD: ::std::os::raw::c_uint = 16;
pub const ACONFIGURATION_KEYBOARD_HIDDEN: ::std::os::raw::c_uint = 32;
pub const ACONFIGURATION_NAVIGATION: ::std::os::raw::c_uint = 64;
pub const ACONFIGURATION_ORIENTATION: ::std::os::raw::c_uint = 128;
pub const ACONFIGURATION_DENSITY: ::std::os::raw::c_uint = 256;
pub const ACONFIGURATION_SCREEN_SIZE: ::std::os::raw::c_uint = 512;
pub const ACONFIGURATION_VERSION: ::std::os::raw::c_uint = 1024;
pub const ACONFIGURATION_SCREEN_LAYOUT: ::std::os::raw::c_uint = 2048;
pub const ACONFIGURATION_UI_MODE: ::std::os::raw::c_uint = 4096;
pub const ACONFIGURATION_SMALLEST_SCREEN_SIZE: ::std::os::raw::c_uint = 8192;
pub const ACONFIGURATION_LAYOUTDIR: ::std::os::raw::c_uint = 16384;
pub const ACONFIGURATION_SCREEN_ROUND: ::std::os::raw::c_uint = 32768;
pub const ACONFIGURATION_COLOR_MODE: ::std::os::raw::c_uint = 65536;
pub const ACONFIGURATION_MNC_ZERO: ::std::os::raw::c_uint = 65535;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_32 {
    pub cw: __u32,
    pub sw: __u32,
    pub tag: __u32,
    pub ipoff: __u32,
    pub cssel: __u32,
    pub dataoff: __u32,
    pub datasel: __u32,
    pub _st: [_fpreg; 8usize],
    pub status: __u16,
    pub magic: __u16,
    pub _fxsr_env: [__u32; 6usize],
    pub mxcsr: __u32,
    pub reserved: __u32,
    pub _fxsr_st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 8usize],
    pub __bindgen_anon_1: _fpstate_32__bindgen_ty_1,
    pub __bindgen_anon_2: _fpstate_32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_1 {
    pub padding1: [__u32; 44usize],
    pub padding: [__u32; 44usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_2 {
    pub padding2: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).padding2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_32() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32>(),
        624usize,
        concat!("Size of: ", stringify!(_fpstate_32))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).sw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).ipoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(ipoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cssel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cssel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).dataoff as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(dataoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).datasel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(datasel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._st as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).magic as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_env as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).mxcsr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).reserved as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_st as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._xmm as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_xmm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_64 {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_64__bindgen_ty_1 {
    pub reserved3: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
}
#[test]
fn bindgen_test_layout__fpstate_64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).reserved3 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_64() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate_64))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).reserved2 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout__header() {
    assert_eq!(
        ::std::mem::size_of::<_header>(),
        64usize,
        concat!("Size of: ", stringify!(_header))
    );
    assert_eq!(
        ::std::mem::align_of::<_header>(),
        4usize,
        concat!("Alignment of ", stringify!(_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate_32,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        944usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        4usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_32 {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub di: __u32,
    pub si: __u32,
    pub bp: __u32,
    pub sp: __u32,
    pub bx: __u32,
    pub dx: __u32,
    pub cx: __u32,
    pub ax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub ip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub flags: __u32,
    pub sp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: __u32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[test]
fn bindgen_test_layout_sigcontext_32() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_32>(),
        88usize,
        concat!("Size of: ", stringify!(sigcontext_32))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_32>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).gs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__gsh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__gsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__fsh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__fsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).es as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__esh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__esh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__dsh as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__dsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).di as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).si as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).dx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).trapno as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).err as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__csh as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__csh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp_at_signal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp_at_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ss as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__ssh as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__ssh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fpstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_64 {
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub di: __u64,
    pub si: __u64,
    pub bp: __u64,
    pub bx: __u64,
    pub dx: __u64,
    pub ax: __u64,
    pub cx: __u64,
    pub sp: __u64,
    pub ip: __u64,
    pub flags: __u64,
    pub cs: __u16,
    pub gs: __u16,
    pub fs: __u16,
    pub ss: __u16,
    pub err: __u64,
    pub trapno: __u64,
    pub oldmask: __u64,
    pub cr2: __u64,
    pub fpstate: __u64,
    pub reserved1: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_sigcontext_64() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_64>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext_64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_64>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).di as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).si as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).sp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ss as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fpstate as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub edi: __u32,
    pub esi: __u32,
    pub ebp: __u32,
    pub esp: __u32,
    pub ebx: __u32,
    pub edx: __u32,
    pub ecx: __u32,
    pub eax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub eip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub eflags: __u32,
    pub esp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: *mut _fpstate_32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        88usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__gsh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__gsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__fsh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__fsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).es as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__esh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__esh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).ds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__dsh as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__dsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).edi as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(edi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).esi as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(esi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).ebp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(ebp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).esp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).ebx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).edx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(edx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).ecx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__csh as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__csh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).esp_at_signal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(esp_at_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).ss as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__ssh as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__ssh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fpstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[test]
fn bindgen_test_layout___kernel_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_itimerspec>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[test]
fn bindgen_test_layout___kernel_old_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timeval>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[test]
fn bindgen_test_layout___kernel_sock_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sock_timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __kernel_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __kernel_time_t,
    pub tv_usec: __kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        16usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        4usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        16usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        4usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = ::std::os::raw::c_ulong;
pub type __signalfn_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sigaction {
    pub _u: __kernel_sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_ulong,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sigaction__bindgen_ty_1 {
    pub _sa_handler: __sighandler_t,
    pub _sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___kernel_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sigaction__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__kernel_sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sigaction__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__kernel_sigaction__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_sigaction__bindgen_ty_1>()))._sa_handler as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction__bindgen_ty_1),
            "::",
            stringify!(_sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_sigaction__bindgen_ty_1>()))._sa_sigaction as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction__bindgen_ty_1),
            "::",
            stringify!(_sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout___kernel_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sigaction>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>()))._u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sigaction>())).sa_restorer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        12usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        4usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        4usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::std::os::raw::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sys_private as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_3>(),
        12usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::std::os::raw::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_4>(),
        20usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._utime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_lsb: ::std::os::raw::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::std::os::raw::c_char; 4usize],
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._dummy_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._lower
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._upper
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::std::os::raw::c_char; 4usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._dummy_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))._pkey
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_5>()))._addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::std::os::raw::c_long,
    pub _fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._band as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_7>(),
        12usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._call_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._arch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields() {
    assert_eq!(
        ::std::mem::size_of::<__sifields>(),
        20usize,
        concat!("Size of: ", stringify!(__sifields))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [::std::os::raw::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_signo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_errno as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_code as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._sifields as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo__bindgen_ty_1>()))._si_pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_si_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 13usize],
    pub _tid: ::std::os::raw::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        52usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        4usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type sig_t = __sighandler_t;
pub type sighandler_t = __sighandler_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset64_t {
    pub __bits: [::std::os::raw::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_sigset64_t() {
    assert_eq!(
        ::std::mem::size_of::<sigset64_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sigset64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sigset64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigset64_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset64_t),
            "::",
            stringify!(__bits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __bindgen_anon_1: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction64 {
    pub __bindgen_anon_1: sigaction64__bindgen_ty_1,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
    pub sa_mask: sigset64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction64__bindgen_ty_1 {
    pub sa_handler: sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction64__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction64__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction64__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction64() {
    assert_eq!(
        ::std::mem::size_of::<sigaction64>(),
        20usize,
        concat!("Size of: ", stringify!(sigaction64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction64>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_restorer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_restorer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction64>())).sa_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction64),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_fpregs_struct {
    pub cwd: ::std::os::raw::c_long,
    pub swd: ::std::os::raw::c_long,
    pub twd: ::std::os::raw::c_long,
    pub fip: ::std::os::raw::c_long,
    pub fcs: ::std::os::raw::c_long,
    pub foo: ::std::os::raw::c_long,
    pub fos: ::std::os::raw::c_long,
    pub st_space: [::std::os::raw::c_long; 20usize],
}
#[test]
fn bindgen_test_layout_user_fpregs_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_fpregs_struct>(),
        108usize,
        concat!("Size of: ", stringify!(user_fpregs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_fpregs_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(user_fpregs_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpregs_struct>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpregs_struct),
            "::",
            stringify!(st_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_fpxregs_struct {
    pub cwd: ::std::os::raw::c_ushort,
    pub swd: ::std::os::raw::c_ushort,
    pub twd: ::std::os::raw::c_ushort,
    pub fop: ::std::os::raw::c_ushort,
    pub fip: ::std::os::raw::c_long,
    pub fcs: ::std::os::raw::c_long,
    pub foo: ::std::os::raw::c_long,
    pub fos: ::std::os::raw::c_long,
    pub mxcsr: ::std::os::raw::c_long,
    pub reserved: ::std::os::raw::c_long,
    pub st_space: [::std::os::raw::c_long; 32usize],
    pub xmm_space: [::std::os::raw::c_long; 32usize],
    pub padding: [::std::os::raw::c_long; 56usize],
}
#[test]
fn bindgen_test_layout_user_fpxregs_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_fpxregs_struct>(),
        512usize,
        concat!("Size of: ", stringify!(user_fpxregs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_fpxregs_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(user_fpxregs_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).fip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).fcs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).foo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).fos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_fpxregs_struct>())).padding as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(user_fpxregs_struct),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_regs_struct {
    pub ebx: ::std::os::raw::c_long,
    pub ecx: ::std::os::raw::c_long,
    pub edx: ::std::os::raw::c_long,
    pub esi: ::std::os::raw::c_long,
    pub edi: ::std::os::raw::c_long,
    pub ebp: ::std::os::raw::c_long,
    pub eax: ::std::os::raw::c_long,
    pub xds: ::std::os::raw::c_long,
    pub xes: ::std::os::raw::c_long,
    pub xfs: ::std::os::raw::c_long,
    pub xgs: ::std::os::raw::c_long,
    pub orig_eax: ::std::os::raw::c_long,
    pub eip: ::std::os::raw::c_long,
    pub xcs: ::std::os::raw::c_long,
    pub eflags: ::std::os::raw::c_long,
    pub esp: ::std::os::raw::c_long,
    pub xss: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_user_regs_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_regs_struct>(),
        68usize,
        concat!("Size of: ", stringify!(user_regs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_regs_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(user_regs_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).ebx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).ecx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).edx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(edx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).esi as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(esi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).edi as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(edi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).ebp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(ebp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).eax as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xds as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xfs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xgs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).orig_eax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(orig_eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).eip as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xcs as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).eflags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).esp as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_regs_struct>())).xss as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(user_regs_struct),
            "::",
            stringify!(xss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {
    pub regs: user_regs_struct,
    pub u_fpvalid: ::std::os::raw::c_int,
    pub i387: user_fpregs_struct,
    pub u_tsize: ::std::os::raw::c_ulong,
    pub u_dsize: ::std::os::raw::c_ulong,
    pub u_ssize: ::std::os::raw::c_ulong,
    pub start_code: ::std::os::raw::c_ulong,
    pub start_stack: ::std::os::raw::c_ulong,
    pub signal: ::std::os::raw::c_long,
    pub reserved: ::std::os::raw::c_int,
    pub u_ar0: *mut user_regs_struct,
    pub u_fpstate: *mut user_fpregs_struct,
    pub magic: ::std::os::raw::c_ulong,
    pub u_comm: [::std::os::raw::c_char; 32usize],
    pub u_debugreg: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_user() {
    assert_eq!(
        ::std::mem::size_of::<user>(),
        284usize,
        concat!("Size of: ", stringify!(user))
    );
    assert_eq!(
        ::std::mem::align_of::<user>(),
        4usize,
        concat!("Alignment of ", stringify!(user))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_fpvalid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_fpvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).i387 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(i387)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_tsize as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_tsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_dsize as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_dsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_ssize as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_ssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).start_code as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(start_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).start_stack as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(start_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).signal as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).reserved as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_ar0 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_ar0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_fpstate as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).magic as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_comm as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user>())).u_debugreg as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(user),
            "::",
            stringify!(u_debugreg)
        )
    );
}
pub const REG_GS: ::std::os::raw::c_uint = 0;
pub const REG_FS: ::std::os::raw::c_uint = 1;
pub const REG_ES: ::std::os::raw::c_uint = 2;
pub const REG_DS: ::std::os::raw::c_uint = 3;
pub const REG_EDI: ::std::os::raw::c_uint = 4;
pub const REG_ESI: ::std::os::raw::c_uint = 5;
pub const REG_EBP: ::std::os::raw::c_uint = 6;
pub const REG_ESP: ::std::os::raw::c_uint = 7;
pub const REG_EBX: ::std::os::raw::c_uint = 8;
pub const REG_EDX: ::std::os::raw::c_uint = 9;
pub const REG_ECX: ::std::os::raw::c_uint = 10;
pub const REG_EAX: ::std::os::raw::c_uint = 11;
pub const REG_TRAPNO: ::std::os::raw::c_uint = 12;
pub const REG_ERR: ::std::os::raw::c_uint = 13;
pub const REG_EIP: ::std::os::raw::c_uint = 14;
pub const REG_CS: ::std::os::raw::c_uint = 15;
pub const REG_EFL: ::std::os::raw::c_uint = 16;
pub const REG_UESP: ::std::os::raw::c_uint = 17;
pub const REG_SS: ::std::os::raw::c_uint = 18;
pub const NGREG: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub type greg_t = ::std::os::raw::c_int;
pub type gregset_t = [greg_t; 19usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__libc_fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_libc_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cw: ::std::os::raw::c_ulong,
    pub sw: ::std::os::raw::c_ulong,
    pub tag: ::std::os::raw::c_ulong,
    pub ipoff: ::std::os::raw::c_ulong,
    pub cssel: ::std::os::raw::c_ulong,
    pub dataoff: ::std::os::raw::c_ulong,
    pub datasel: ::std::os::raw::c_ulong,
    pub _st: [_libc_fpreg; 8usize],
    pub status: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        112usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).sw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ipoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ipoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cssel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cssel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).dataoff as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(dataoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).datasel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(datasel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(status)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub oldmask: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        88usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub __bindgen_anon_1: ucontext__bindgen_ty_1,
    pub __fpregs_mem: _libc_fpstate,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucontext__bindgen_ty_1 {
    pub __bindgen_anon_1: ucontext__bindgen_ty_1__bindgen_ty_1,
    pub uc_sigmask64: sigset64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext__bindgen_ty_1__bindgen_ty_1 {
    pub uc_sigmask: sigset_t,
    pub __padding_rt_sigset: u32,
}
#[test]
fn bindgen_test_layout_ucontext__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ucontext__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ucontext__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ucontext__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucontext__bindgen_ty_1__bindgen_ty_1>())).uc_sigmask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucontext__bindgen_ty_1__bindgen_ty_1>())).__padding_rt_sigset
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__padding_rt_sigset)
        )
    );
}
#[test]
fn bindgen_test_layout_ucontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ucontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ucontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucontext__bindgen_ty_1>())).uc_sigmask64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext__bindgen_ty_1),
            "::",
            stringify!(uc_sigmask64)
        )
    );
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        228usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        4usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_link as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_mcontext as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).__fpregs_mem as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(__fpregs_mem)
        )
    );
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub fn sigaction(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction,
        __old_action: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction64(
        __signal: ::std::os::raw::c_int,
        __new_action: *const sigaction64,
        __old_action: *mut sigaction64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        __signal: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn sigaddset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(
        __set: *mut sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset64(
        __set: *mut sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember64(
        __set: *const sigset64_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending64(__set: *mut sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset_t,
        __old_set: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask64(
        __how: ::std::os::raw::c_int,
        __new_set: *const sigset64_t,
        __old_set: *mut sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__mask: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend64(__mask: *const sigset64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait64(
        __set: *const sigset64_t,
        __signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(__signal: ::std::os::raw::c_int, __handler: sighandler_t) -> sighandler_t;
}
extern "C" {
    pub fn raise(__signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill(__pid: pid_t, __signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(
        __pgrp: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tgkill(
        __tgid: ::std::os::raw::c_int,
        __tid: ::std::os::raw::c_int,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(
        __new_signal_stack: *const stack_t,
        __old_signal_stack: *mut stack_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psiginfo(__info: *const siginfo_t, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psignal(__signal: ::std::os::raw::c_int, __msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigqueue(
        __pid: pid_t,
        __signal: ::std::os::raw::c_int,
        __value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait64(
        __set: *const sigset64_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo64(__set: *const sigset64_t, __info: *mut siginfo_t)
        -> ::std::os::raw::c_int;
}
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [fd_mask; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __FD_CLR_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: size_t);
}
extern "C" {
    pub fn __FD_SET_chk(arg1: ::std::os::raw::c_int, arg2: *mut fd_set, arg3: size_t);
}
extern "C" {
    pub fn __FD_ISSET_chk(
        arg1: ::std::os::raw::c_int,
        arg2: *const fd_set,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        __fd_count: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __fd_count: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect64(
        __fd_count: ::std::os::raw::c_int,
        __read_fds: *mut fd_set,
        __write_fds: *mut fd_set,
        __exception_fds: *mut fd_set,
        __timeout: *const timespec,
        __mask: *const sigset64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(
        __which: ::std::os::raw::c_int,
        __current_value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::std::os::raw::c_int,
        __new_value: *const itimerval,
        __old_value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __path: *const ::std::os::raw::c_char,
        __times: *const timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        44usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub fn time(__t: *mut time_t) -> time_t;
}
extern "C" {
    pub fn nanosleep(
        __request: *const timespec,
        __remainder: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(__tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tm: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(__lhs: time_t, __rhs: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn localtime(__t: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__t: *const time_t, __tm: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn gmtime(__t: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__t: *const time_t, __tm: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *mut tm,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strftime(
        __buf: *mut ::std::os::raw::c_char,
        __n: size_t,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __buf: *mut ::std::os::raw::c_char,
        __n: size_t,
        __fmt: *const ::std::os::raw::c_char,
        __tm: *const tm,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn ctime(__t: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __t: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock: clockid_t, __resolution: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock: clockid_t, __ts: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock: clockid_t,
        __flags: ::std::os::raw::c_int,
        __request: *const timespec,
        __remainder: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock: clockid_t, __ts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock: clockid_t,
        __event: *mut sigevent,
        __timer_ptr: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timer: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timer: timer_t,
        __flags: ::std::os::raw::c_int,
        __new_value: *const itimerspec,
        __old_value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timer: timer_t, __ts: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timer: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timelocal(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(__tm: *mut tm) -> time_t;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type nfds_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn poll(
        __fds: *mut pollfd,
        __count: nfds_t,
        __timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppoll(
        __fds: *mut pollfd,
        __count: nfds_t,
        __timeout: *const timespec,
        __mask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppoll64(
        __fds: *mut pollfd,
        __count: nfds_t,
        __timeout: *const timespec,
        __mask: *const sigset64_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct clone_args {
    pub flags: __u64,
    pub pidfd: __u64,
    pub child_tid: __u64,
    pub parent_tid: __u64,
    pub exit_signal: __u64,
    pub stack: __u64,
    pub stack_size: __u64,
    pub tls: __u64,
}
#[test]
fn bindgen_test_layout_clone_args() {
    assert_eq!(
        ::std::mem::size_of::<clone_args>(),
        64usize,
        concat!("Size of: ", stringify!(clone_args))
    );
    assert_eq!(
        ::std::mem::align_of::<clone_args>(),
        8usize,
        concat!("Alignment of ", stringify!(clone_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).pidfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(pidfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).child_tid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).parent_tid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(parent_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).exit_signal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).stack as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).stack_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).tls as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(tls)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setparam(__pid: pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: pid_t, __quantum: *mut timespec) -> ::std::os::raw::c_int;
}
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub type __pthread_cleanup_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_t {
    pub __cleanup_prev: *mut __pthread_cleanup_t,
    pub __cleanup_routine: __pthread_cleanup_func_t,
    pub __cleanup_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_t>(),
        12usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_t>())).__cleanup_prev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_t),
            "::",
            stringify!(__cleanup_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_t>())).__cleanup_routine as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_t),
            "::",
            stringify!(__cleanup_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_t>())).__cleanup_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_t),
            "::",
            stringify!(__cleanup_arg)
        )
    );
}
extern "C" {
    pub fn __pthread_cleanup_push(
        c: *mut __pthread_cleanup_t,
        arg1: __pthread_cleanup_func_t,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __pthread_cleanup_pop(arg1: *mut __pthread_cleanup_t, arg2: ::std::os::raw::c_int);
}
#[doc = " Data associated with an ALooper fd that will be returned as the \"outData\""]
#[doc = " when that source has data ready."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct android_poll_source {
    #[doc = " The identifier of this source.  May be LOOPER_ID_MAIN or"]
    #[doc = " LOOPER_ID_INPUT."]
    pub id: i32,
    #[doc = " The android_app this ident is associated with."]
    pub app: *mut android_app,
    #[doc = " Function to call to perform the standard processing of data from"]
    #[doc = " this source."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(app: *mut android_app, source: *mut android_poll_source),
    >,
}
#[test]
fn bindgen_test_layout_android_poll_source() {
    assert_eq!(
        ::std::mem::size_of::<android_poll_source>(),
        12usize,
        concat!("Size of: ", stringify!(android_poll_source))
    );
    assert_eq!(
        ::std::mem::align_of::<android_poll_source>(),
        4usize,
        concat!("Alignment of ", stringify!(android_poll_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_poll_source>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(android_poll_source),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_poll_source>())).app as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(android_poll_source),
            "::",
            stringify!(app)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_poll_source>())).process as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(android_poll_source),
            "::",
            stringify!(process)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct android_input_buffer {
    #[doc = " Pointer to a read-only array of pointers to GameActivityMotionEvent."]
    #[doc = " Only the first motionEventsCount events are valid."]
    pub motionEvents: [GameActivityMotionEvent; 16usize],
    #[doc = " The number of valid motion events in `motionEvents`."]
    pub motionEventsCount: u64,
    #[doc = " Pointer to a read-only array of pointers to GameActivityHistoricalPointerAxes."]
    #[doc = ""]
    #[doc = " Only the first historicalSamplesCount samples are valid."]
    #[doc = " Refer to event->historicalStart, event->pointerCount and event->historicalCount"]
    #[doc = " to access the specific samples that relate to an event."]
    #[doc = ""]
    #[doc = " Each slice of samples for one event has a length of"]
    #[doc = " (event->pointerCount and event->historicalCount) and is in pointer-major"]
    #[doc = " order so the historic samples for each pointer are contiguous."]
    #[doc = " E.g. you would access historic sample index 3 for pointer 2 of an event with:"]
    #[doc = ""]
    #[doc = "   historicalAxisSamples[event->historicalStart + (event->historicalCount * 2) + 3];"]
    pub historicalAxisSamples: [GameActivityHistoricalPointerAxes; 64usize],
    #[doc = " The number of valid historical samples in `historicalAxisSamples`."]
    pub historicalSamplesCount: u64,
    #[doc = " Pointer to a read-only array of pointers to GameActivityKeyEvent."]
    #[doc = " Only the first keyEventsCount events are valid."]
    pub keyEvents: [GameActivityKeyEvent; 4usize],
    #[doc = " The number of valid \"Key\" events in `keyEvents`."]
    pub keyEventsCount: u64,
}
#[test]
fn bindgen_test_layout_android_input_buffer() {
    assert_eq!(
        ::std::mem::size_of::<android_input_buffer>(),
        40744usize,
        concat!("Size of: ", stringify!(android_input_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<android_input_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(android_input_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_input_buffer>())).motionEvents as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(motionEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_input_buffer>())).motionEventsCount as *const _ as usize
        },
        27712usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(motionEventsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_input_buffer>())).historicalAxisSamples as *const _
                as usize
        },
        27720usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(historicalAxisSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_input_buffer>())).historicalSamplesCount as *const _
                as usize
        },
        40520usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(historicalSamplesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_input_buffer>())).keyEvents as *const _ as usize },
        40528usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(keyEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_input_buffer>())).keyEventsCount as *const _ as usize
        },
        40736usize,
        concat!(
            "Offset of field: ",
            stringify!(android_input_buffer),
            "::",
            stringify!(keyEventsCount)
        )
    );
}
#[doc = " Function pointer declaration for the filtering of key events."]
#[doc = " A function with this signature should be passed to"]
#[doc = " android_app_set_key_event_filter and return false for any events that should"]
#[doc = " not be handled by android_native_app_glue. These events will be handled by"]
#[doc = " the system instead."]
pub type android_key_event_filter =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const GameActivityKeyEvent) -> bool>;
#[doc = " Function pointer definition for the filtering of motion events."]
#[doc = " A function with this signature should be passed to"]
#[doc = " android_app_set_motion_event_filter and return false for any events that"]
#[doc = " should not be handled by android_native_app_glue. These events will be"]
#[doc = " handled by the system instead."]
pub type android_motion_event_filter =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const GameActivityMotionEvent) -> bool>;
#[doc = " The GameActivity interface provided by <game-activity/GameActivity.h>"]
#[doc = " is based on a set of application-provided callbacks that will be called"]
#[doc = " by the Activity's main thread when certain events occur."]
#[doc = ""]
#[doc = " This means that each one of this callbacks _should_ _not_ block, or they"]
#[doc = " risk having the system force-close the application. This programming"]
#[doc = " model is direct, lightweight, but constraining."]
#[doc = ""]
#[doc = " The 'android_native_app_glue' static library is used to provide a different"]
#[doc = " execution model where the application can implement its own main event"]
#[doc = " loop in a different thread instead. Here's how it works:"]
#[doc = ""]
#[doc = " 1/ The application must provide a function named \"android_main()\" that"]
#[doc = "    will be called when the activity is created, in a new thread that is"]
#[doc = "    distinct from the activity's main thread."]
#[doc = ""]
#[doc = " 2/ android_main() receives a pointer to a valid \"android_app\" structure"]
#[doc = "    that contains references to other important objects, e.g. the"]
#[doc = "    GameActivity obejct instance the application is running in."]
#[doc = ""]
#[doc = " 3/ the \"android_app\" object holds an ALooper instance that already"]
#[doc = "    listens to activity lifecycle events (e.g. \"pause\", \"resume\")."]
#[doc = "    See APP_CMD_XXX declarations below."]
#[doc = ""]
#[doc = "    This corresponds to an ALooper identifier returned by"]
#[doc = "    ALooper_pollOnce with value LOOPER_ID_MAIN."]
#[doc = ""]
#[doc = "    Your application can use the same ALooper to listen to additional"]
#[doc = "    file-descriptors.  They can either be callback based, or with return"]
#[doc = "    identifiers starting with LOOPER_ID_USER."]
#[doc = ""]
#[doc = " 4/ Whenever you receive a LOOPER_ID_MAIN event,"]
#[doc = "    the returned data will point to an android_poll_source structure.  You"]
#[doc = "    can call the process() function on it, and fill in android_app->onAppCmd"]
#[doc = "    to be called for your own processing of the event."]
#[doc = ""]
#[doc = "    Alternatively, you can call the low-level functions to read and process"]
#[doc = "    the data directly...  look at the process_cmd() and process_input()"]
#[doc = "    implementations in the glue to see how to do this."]
#[doc = ""]
#[doc = " See the sample named \"native-activity\" that comes with the NDK with a"]
#[doc = " full usage example.  Also look at the documentation of GameActivity."]
#[repr(C)]
pub struct android_app {
    #[doc = " An optional pointer to application-defined state."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " A required callback for processing main app commands (`APP_CMD_*`)."]
    #[doc = " This is called each frame if there are app commands that need processing."]
    pub onAppCmd: ::std::option::Option<unsafe extern "C" fn(app: *mut android_app, cmd: i32)>,
    #[doc = " The GameActivity object instance that this app is running in."]
    pub activity: *mut GameActivity,
    #[doc = " The current configuration the app is running in."]
    pub config: *mut AConfiguration,
    #[doc = " The last activity saved state, as provided at creation time."]
    #[doc = " It is NULL if there was no state.  You can use this as you need; the"]
    #[doc = " memory will remain around until you call android_app_exec_cmd() for"]
    #[doc = " APP_CMD_RESUME, at which point it will be freed and savedState set to"]
    #[doc = " NULL. These variables should only be changed when processing a"]
    #[doc = " APP_CMD_SAVE_STATE, at which point they will be initialized to NULL and"]
    #[doc = " you can malloc your state and place the information here.  In that case"]
    #[doc = " the memory will be freed for you later."]
    pub savedState: *mut ::std::os::raw::c_void,
    #[doc = " The size of the activity saved state. It is 0 if `savedState` is NULL."]
    pub savedStateSize: size_t,
    #[doc = " The ALooper associated with the app's thread."]
    pub looper: *mut ALooper,
    #[doc = " When non-NULL, this is the window surface that the app can draw in."]
    pub window: *mut ANativeWindow,
    #[doc = " Current content rectangle of the window; this is the area where the"]
    #[doc = " window's content should be placed to be seen by the user."]
    pub contentRect: ARect,
    #[doc = " Current state of the app's activity.  May be either APP_CMD_START,"]
    #[doc = " APP_CMD_RESUME, APP_CMD_PAUSE, or APP_CMD_STOP."]
    pub activityState: ::std::os::raw::c_int,
    #[doc = " This is non-zero when the application's GameActivity is being"]
    #[doc = " destroyed and waiting for the app thread to complete."]
    pub destroyRequested: ::std::os::raw::c_int,
    #[doc = " This is used for buffering input from GameActivity. Once ready, the"]
    #[doc = " application thread switches the buffers and processes what was"]
    #[doc = " accumulated."]
    pub inputBuffers: [android_input_buffer; 2usize],
    pub currentInputBuffer: ::std::os::raw::c_int,
    #[doc = " 0 if no text input event is outstanding, 1 if it is."]
    #[doc = " Use `GameActivity_getTextInputState` to get information"]
    #[doc = " about the text entered by the user."]
    pub textInputState: ::std::os::raw::c_int,
    #[doc = " @cond INTERNAL"]
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub msgread: ::std::os::raw::c_int,
    pub msgwrite: ::std::os::raw::c_int,
    pub thread: pthread_t,
    pub cmdPollSource: android_poll_source,
    pub running: ::std::os::raw::c_int,
    pub stateSaved: ::std::os::raw::c_int,
    pub destroyed: ::std::os::raw::c_int,
    pub redrawNeeded: ::std::os::raw::c_int,
    pub pendingWindow: *mut ANativeWindow,
    pub pendingContentRect: ARect,
    pub keyEventFilter: android_key_event_filter,
    pub motionEventFilter: android_motion_event_filter,
    pub inputAvailableWakeUp: bool,
    pub inputSwapPending: bool,
}
#[test]
fn bindgen_test_layout_android_app() {
    assert_eq!(
        ::std::mem::size_of::<android_app>(),
        81632usize,
        concat!("Size of: ", stringify!(android_app))
    );
    assert_eq!(
        ::std::mem::align_of::<android_app>(),
        4usize,
        concat!("Alignment of ", stringify!(android_app))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).userData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).onAppCmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(onAppCmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).activity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(activity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).config as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).savedState as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(savedState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).savedStateSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(savedStateSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).looper as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(looper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).window as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).contentRect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(contentRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).activityState as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(activityState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).destroyRequested as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(destroyRequested)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).inputBuffers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(inputBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).currentInputBuffer as *const _ as usize },
        81544usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(currentInputBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).textInputState as *const _ as usize },
        81548usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(textInputState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).mutex as *const _ as usize },
        81552usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).cond as *const _ as usize },
        81556usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).msgread as *const _ as usize },
        81560usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(msgread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).msgwrite as *const _ as usize },
        81564usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(msgwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).thread as *const _ as usize },
        81568usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).cmdPollSource as *const _ as usize },
        81572usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(cmdPollSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).running as *const _ as usize },
        81584usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).stateSaved as *const _ as usize },
        81588usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(stateSaved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).destroyed as *const _ as usize },
        81592usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).redrawNeeded as *const _ as usize },
        81596usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(redrawNeeded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).pendingWindow as *const _ as usize },
        81600usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(pendingWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).pendingContentRect as *const _ as usize },
        81604usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(pendingContentRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).keyEventFilter as *const _ as usize },
        81620usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(keyEventFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).motionEventFilter as *const _ as usize },
        81624usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(motionEventFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<android_app>())).inputAvailableWakeUp as *const _ as usize
        },
        81628usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(inputAvailableWakeUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<android_app>())).inputSwapPending as *const _ as usize },
        81629usize,
        concat!(
            "Offset of field: ",
            stringify!(android_app),
            "::",
            stringify!(inputSwapPending)
        )
    );
}
#[doc = " Looper data ID of commands coming from the app's main thread, which"]
#[doc = " is returned as an identifier from ALooper_pollOnce().  The data for this"]
#[doc = " identifier is a pointer to an android_poll_source structure."]
#[doc = " These can be retrieved and processed with android_app_read_cmd()"]
#[doc = " and android_app_exec_cmd()."]
pub const NativeAppGlueLooperId_LOOPER_ID_MAIN: NativeAppGlueLooperId = 1;
#[doc = " Unused. Reserved for future use when usage of AInputQueue will be"]
#[doc = " supported."]
pub const NativeAppGlueLooperId_LOOPER_ID_INPUT: NativeAppGlueLooperId = 2;
#[doc = " Start of user-defined ALooper identifiers."]
pub const NativeAppGlueLooperId_LOOPER_ID_USER: NativeAppGlueLooperId = 3;
#[doc = " Looper ID of commands coming from the app's main thread, an AInputQueue or"]
#[doc = " user-defined sources."]
pub type NativeAppGlueLooperId = ::std::os::raw::c_uint;
#[doc = " Unused. Reserved for future use when usage of AInputQueue will be"]
#[doc = " supported."]
pub const NativeAppGlueAppCmd_UNUSED_APP_CMD_INPUT_CHANGED: NativeAppGlueAppCmd = 0;
#[doc = " Command from main thread: a new ANativeWindow is ready for use.  Upon"]
#[doc = " receiving this command, android_app->window will contain the new window"]
#[doc = " surface."]
pub const NativeAppGlueAppCmd_APP_CMD_INIT_WINDOW: NativeAppGlueAppCmd = 1;
#[doc = " Command from main thread: the existing ANativeWindow needs to be"]
#[doc = " terminated.  Upon receiving this command, android_app->window still"]
#[doc = " contains the existing window; after calling android_app_exec_cmd"]
#[doc = " it will be set to NULL."]
pub const NativeAppGlueAppCmd_APP_CMD_TERM_WINDOW: NativeAppGlueAppCmd = 2;
#[doc = " Command from main thread: the current ANativeWindow has been resized."]
#[doc = " Please redraw with its new size."]
pub const NativeAppGlueAppCmd_APP_CMD_WINDOW_RESIZED: NativeAppGlueAppCmd = 3;
#[doc = " Command from main thread: the system needs that the current ANativeWindow"]
#[doc = " be redrawn.  You should redraw the window before handing this to"]
#[doc = " android_app_exec_cmd() in order to avoid transient drawing glitches."]
pub const NativeAppGlueAppCmd_APP_CMD_WINDOW_REDRAW_NEEDED: NativeAppGlueAppCmd = 4;
#[doc = " Command from main thread: the content area of the window has changed,"]
#[doc = " such as from the soft input window being shown or hidden.  You can"]
#[doc = " find the new content rect in android_app::contentRect."]
pub const NativeAppGlueAppCmd_APP_CMD_CONTENT_RECT_CHANGED: NativeAppGlueAppCmd = 5;
#[doc = " Command from main thread: the app's activity window has gained"]
#[doc = " input focus."]
pub const NativeAppGlueAppCmd_APP_CMD_GAINED_FOCUS: NativeAppGlueAppCmd = 6;
#[doc = " Command from main thread: the app's activity window has lost"]
#[doc = " input focus."]
pub const NativeAppGlueAppCmd_APP_CMD_LOST_FOCUS: NativeAppGlueAppCmd = 7;
#[doc = " Command from main thread: the current device configuration has changed."]
pub const NativeAppGlueAppCmd_APP_CMD_CONFIG_CHANGED: NativeAppGlueAppCmd = 8;
#[doc = " Command from main thread: the system is running low on memory."]
#[doc = " Try to reduce your memory use."]
pub const NativeAppGlueAppCmd_APP_CMD_LOW_MEMORY: NativeAppGlueAppCmd = 9;
#[doc = " Command from main thread: the app's activity has been started."]
pub const NativeAppGlueAppCmd_APP_CMD_START: NativeAppGlueAppCmd = 10;
#[doc = " Command from main thread: the app's activity has been resumed."]
pub const NativeAppGlueAppCmd_APP_CMD_RESUME: NativeAppGlueAppCmd = 11;
#[doc = " Command from main thread: the app should generate a new saved state"]
#[doc = " for itself, to restore from later if needed.  If you have saved state,"]
#[doc = " allocate it with malloc and place it in android_app.savedState with"]
#[doc = " the size in android_app.savedStateSize.  The will be freed for you"]
#[doc = " later."]
pub const NativeAppGlueAppCmd_APP_CMD_SAVE_STATE: NativeAppGlueAppCmd = 12;
#[doc = " Command from main thread: the app's activity has been paused."]
pub const NativeAppGlueAppCmd_APP_CMD_PAUSE: NativeAppGlueAppCmd = 13;
#[doc = " Command from main thread: the app's activity has been stopped."]
pub const NativeAppGlueAppCmd_APP_CMD_STOP: NativeAppGlueAppCmd = 14;
#[doc = " Command from main thread: the app's activity is being destroyed,"]
#[doc = " and waiting for the app thread to clean up and exit before proceeding."]
pub const NativeAppGlueAppCmd_APP_CMD_DESTROY: NativeAppGlueAppCmd = 15;
#[doc = " Command from main thread: the app's insets have changed."]
pub const NativeAppGlueAppCmd_APP_CMD_WINDOW_INSETS_CHANGED: NativeAppGlueAppCmd = 16;
#[doc = " Commands passed from the application's main Java thread to the game's thread."]
pub type NativeAppGlueAppCmd = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Call when ALooper_pollAll() returns LOOPER_ID_MAIN, reading the next"]
    #[doc = " app command message."]
    pub fn android_app_read_cmd(android_app: *mut android_app) -> i8;
}
extern "C" {
    #[doc = " Call with the command returned by android_app_read_cmd() to do the"]
    #[doc = " initial pre-processing of the given command.  You can perform your own"]
    #[doc = " actions for the command after calling this function."]
    pub fn android_app_pre_exec_cmd(android_app: *mut android_app, cmd: i8);
}
extern "C" {
    #[doc = " Call with the command returned by android_app_read_cmd() to do the"]
    #[doc = " final post-processing of the given command.  You must have done your own"]
    #[doc = " actions for the command before calling this function."]
    pub fn android_app_post_exec_cmd(android_app: *mut android_app, cmd: i8);
}
extern "C" {
    #[doc = " Call this before processing input events to get the events buffer."]
    #[doc = " The function returns NULL if there are no events to process."]
    pub fn android_app_swap_input_buffers(
        android_app: *mut android_app,
    ) -> *mut android_input_buffer;
}
extern "C" {
    #[doc = " Clear the array of motion events that were waiting to be handled, and release"]
    #[doc = " each of them."]
    #[doc = ""]
    #[doc = " This method should be called after you have processed the motion events in"]
    #[doc = " your game loop. You should handle events at each iteration of your game loop."]
    pub fn android_app_clear_motion_events(inputBuffer: *mut android_input_buffer);
}
extern "C" {
    #[doc = " Clear the array of key events that were waiting to be handled, and release"]
    #[doc = " each of them."]
    #[doc = ""]
    #[doc = " This method should be called after you have processed the key up events in"]
    #[doc = " your game loop. You should handle events at each iteration of your game loop."]
    pub fn android_app_clear_key_events(inputBuffer: *mut android_input_buffer);
}
extern "C" {
    #[doc = " This is a springboard into the Rust glue layer that wraps calling the"]
    #[doc = " main entry for the app itself."]
    pub fn _rust_glue_entry(app: *mut android_app);
}
extern "C" {
    #[doc = " Set the filter to use when processing key events."]
    #[doc = " Any events for which the filter returns false will be ignored by"]
    #[doc = " android_native_app_glue. If filter is set to NULL, no filtering is done."]
    #[doc = ""]
    #[doc = " The default key filter will filter out volume and camera button presses."]
    pub fn android_app_set_key_event_filter(
        app: *mut android_app,
        filter: android_key_event_filter,
    );
}
extern "C" {
    #[doc = " Set the filter to use when processing touch and motion events."]
    #[doc = " Any events for which the filter returns false will be ignored by"]
    #[doc = " android_native_app_glue. If filter is set to NULL, no filtering is done."]
    #[doc = ""]
    #[doc = " Note that the default motion event filter will only allow touchscreen events"]
    #[doc = " through, in order to mimic NativeActivity's behaviour, so for controller"]
    #[doc = " events to be passed to the app, set the filter to NULL."]
    pub fn android_app_set_motion_event_filter(
        app: *mut android_app,
        filter: android_motion_event_filter,
    );
}
extern "C" {
    #[doc = " Determines if a looper wake up was due to new input becoming available"]
    pub fn android_app_input_available_wake_up(app: *mut android_app) -> bool;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
